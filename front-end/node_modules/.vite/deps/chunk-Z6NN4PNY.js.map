{
  "version": 3,
  "sources": ["../../viem/src/accounts/utils/parseAccount.ts", "../../viem/src/constants/abis.ts", "../../viem/src/constants/contract.ts", "../../viem/src/constants/solidity.ts", "../../viem/src/utils/abi/formatAbiItem.ts", "../../viem/src/errors/abi.ts", "../../viem/src/utils/data/slice.ts", "../../viem/src/utils/contract/extractFunctionParts.ts", "../../viem/node_modules/@noble/hashes/src/_assert.ts", "../../viem/node_modules/@noble/hashes/src/_u64.ts", "../../viem/node_modules/@noble/hashes/src/crypto.ts", "../../viem/node_modules/@noble/hashes/src/utils.ts", "../../viem/node_modules/@noble/hashes/src/sha3.ts", "../../viem/src/utils/hash/keccak256.ts", "../../viem/src/utils/hash/hashFunction.ts", "../../viem/src/utils/hash/getFunctionSelector.ts", "../../viem/src/utils/address/getAddress.ts", "../../viem/src/utils/abi/encodeAbiParameters.ts", "../../viem/src/utils/abi/decodeAbiParameters.ts", "../../viem/src/utils/abi/decodeErrorResult.ts", "../../viem/src/utils/stringify.ts", "../../viem/src/utils/abi/formatAbiItemWithArgs.ts", "../../viem/src/utils/abi/getAbiItem.ts", "../../viem/src/errors/contract.ts", "../../viem/src/utils/abi/decodeFunctionResult.ts", "../../viem/src/utils/abi/encodeFunctionData.ts", "../../viem/src/errors/request.ts", "../../viem/src/errors/rpc.ts", "../../viem/src/utils/errors/getNodeError.ts", "../../viem/src/utils/errors/getCallError.ts", "../../viem/src/utils/formatters/extract.ts", "../../viem/src/utils/promise/createBatchScheduler.ts", "../../viem/src/utils/transaction/assertRequest.ts", "../../viem/src/actions/public/call.ts", "../../viem/src/errors/ccip.ts", "../../viem/src/utils/address/isAddressEqual.ts", "../../viem/src/utils/ccip.ts"],
  "sourcesContent": ["import type { Address } from 'abitype'\n\nimport type { Account } from '../types.js'\n\nexport function parseAccount(account: Address | Account): Account {\n  if (typeof account === 'string') return { address: account, type: 'json-rpc' }\n  return account\n}\n", "/* [Multicall3](https://github.com/mds1/multicall) */\nexport const multicall3Abi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            name: 'target',\n            type: 'address',\n          },\n          {\n            name: 'allowFailure',\n            type: 'bool',\n          },\n          {\n            name: 'callData',\n            type: 'bytes',\n          },\n        ],\n        name: 'calls',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'aggregate3',\n    outputs: [\n      {\n        components: [\n          {\n            name: 'success',\n            type: 'bool',\n          },\n          {\n            name: 'returnData',\n            type: 'bytes',\n          },\n        ],\n        name: 'returnData',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n\nconst universalResolverErrors = [\n  {\n    inputs: [],\n    name: 'ResolverNotFound',\n    type: 'error',\n  },\n  {\n    inputs: [],\n    name: 'ResolverWildcardNotSupported',\n    type: 'error',\n  },\n] as const\n\nexport const universalResolverResolveAbi = [\n  ...universalResolverErrors,\n  {\n    name: 'resolve',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes' },\n      { name: 'data', type: 'bytes' },\n    ],\n    outputs: [\n      { name: '', type: 'bytes' },\n      { name: 'address', type: 'address' },\n    ],\n  },\n] as const\n\nexport const universalResolverReverseAbi = [\n  ...universalResolverErrors,\n  {\n    name: 'reverse',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ type: 'bytes', name: 'reverseName' }],\n    outputs: [\n      { type: 'string', name: 'resolvedName' },\n      { type: 'address', name: 'resolvedAddress' },\n      { type: 'address', name: 'reverseResolver' },\n      { type: 'address', name: 'resolver' },\n    ],\n  },\n] as const\n\nexport const textResolverAbi = [\n  {\n    name: 'text',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes32' },\n      { name: 'key', type: 'string' },\n    ],\n    outputs: [{ name: '', type: 'string' }],\n  },\n] as const\n\nexport const addressResolverAbi = [\n  {\n    name: 'addr',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [{ name: 'name', type: 'bytes32' }],\n    outputs: [{ name: '', type: 'address' }],\n  },\n  {\n    name: 'addr',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'name', type: 'bytes32' },\n      { name: 'coinType', type: 'uint256' },\n    ],\n    outputs: [{ name: '', type: 'bytes' }],\n  },\n] as const\n\n// ERC-1271\n// isValidSignature(bytes32 hash, bytes signature) → bytes4 magicValue\nexport const smartAccountAbi = [\n  {\n    name: 'isValidSignature',\n    type: 'function',\n    stateMutability: 'view',\n    inputs: [\n      { name: 'hash', type: 'bytes32' },\n      { name: 'signature', type: 'bytes' },\n    ],\n    outputs: [{ name: '', type: 'bytes4' }],\n  },\n] as const\n\n// ERC-6492 - universal deployless signature validator contract\n// constructor(address _signer, bytes32 _hash, bytes _signature) → bytes4 returnValue\n// returnValue is either 0x1 (valid) or 0x0 (invalid)\nexport const universalSignatureValidatorAbi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_signer',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_hash',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_signature',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n] as const\n", "export const aggregate3Signature = '0x82ad56cb'\n", "import type { AbiError } from 'abitype'\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as const\n\nexport const solidityError: AbiError = {\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n}\nexport const solidityPanic: AbiError = {\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint256',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n}\n", "import type { AbiParameter } from 'abitype'\n\nimport { InvalidDefinitionTypeError } from '../../errors/abi.js'\nimport type { AbiItem } from '../../types/contract.js'\n\nexport function formatAbiItem(\n  abiItem: AbiItem,\n  { includeName = false }: { includeName?: boolean } = {},\n) {\n  if (\n    abiItem.type !== 'function' &&\n    abiItem.type !== 'event' &&\n    abiItem.type !== 'error'\n  )\n    throw new InvalidDefinitionTypeError(abiItem.type)\n\n  return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`\n}\n\nexport function formatAbiParams(\n  params: readonly AbiParameter[] | undefined,\n  { includeName = false }: { includeName?: boolean } = {},\n): string {\n  if (!params) return ''\n  return params\n    .map((param) => formatAbiParam(param, { includeName }))\n    .join(includeName ? ', ' : ',')\n}\n\nfunction formatAbiParam(\n  param: AbiParameter,\n  { includeName }: { includeName: boolean },\n): string {\n  if (param.type.startsWith('tuple')) {\n    return `(${formatAbiParams(\n      (param as unknown as { components: AbiParameter[] }).components,\n      { includeName },\n    )})${param.type.slice('tuple'.length)}`\n  }\n  return param.type + (includeName && param.name ? ` ${param.name}` : '')\n}\n", "import type { AbiEvent, AbiParameter } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { formatAbiItem, formatAbiParams } from '../utils/abi/formatAbiItem.js'\nimport { size } from '../utils/data/size.js'\n\nimport { BaseError } from './base.js'\n\nexport class AbiConstructorNotFoundError extends BaseError {\n  override name = 'AbiConstructorNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'A constructor was not found on the ABI.',\n        'Make sure you are using the correct ABI and that the constructor exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiConstructorParamsNotFoundError extends BaseError {\n  override name = 'AbiConstructorParamsNotFoundError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super(\n      [\n        'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',\n        'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeInvalidError extends BaseError {\n  override name = 'AbiDecodingDataSizeInvalidError'\n  constructor({ data, size }: { data: Hex; size: number }) {\n    super(\n      [\n        `Data size of ${size} bytes is invalid.`,\n        'Size must be in increments of 32 bytes (size % 32 === 0).',\n      ].join('\\n'),\n      { metaMessages: [`Data: ${data} (${size} bytes)`] },\n    )\n  }\n}\n\nexport class AbiDecodingDataSizeTooSmallError extends BaseError {\n  override name = 'AbiDecodingDataSizeTooSmallError'\n\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    data,\n    params,\n    size,\n  }: { data: Hex; params: readonly AbiParameter[]; size: number }) {\n    super(\n      [`Data size of ${size} bytes is too small for given parameters.`].join(\n        '\\n',\n      ),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class AbiDecodingZeroDataError extends BaseError {\n  override name = 'AbiDecodingZeroDataError'\n  constructor() {\n    super('Cannot decode zero data (\"0x\") with ABI parameters.')\n  }\n}\n\nexport class AbiEncodingArrayLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingArrayLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n    type,\n  }: { expectedLength: number; givenLength: number; type: string }) {\n    super(\n      [\n        `ABI encoding array length mismatch for type ${type}.`,\n        `Expected length: ${expectedLength}`,\n        `Given length: ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiEncodingBytesSizeMismatchError extends BaseError {\n  override name = 'AbiEncodingBytesSizeMismatchError'\n  constructor({ expectedSize, value }: { expectedSize: number; value: Hex }) {\n    super(\n      `Size of bytes \"${value}\" (bytes${size(\n        value,\n      )}) does not match expected size (bytes${expectedSize}).`,\n    )\n  }\n}\n\nexport class AbiEncodingLengthMismatchError extends BaseError {\n  override name = 'AbiEncodingLengthMismatchError'\n  constructor({\n    expectedLength,\n    givenLength,\n  }: { expectedLength: number; givenLength: number }) {\n    super(\n      [\n        'ABI encoding params/values length mismatch.',\n        `Expected length (params): ${expectedLength}`,\n        `Given length (values): ${givenLength}`,\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class AbiErrorInputsNotFoundError extends BaseError {\n  override name = 'AbiErrorInputsNotFoundError'\n  constructor(errorName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Arguments (\\`args\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\`inputs\\`).`,\n        'Cannot encode error result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the inputs exist on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorNotFoundError extends BaseError {\n  override name = 'AbiErrorNotFoundError'\n  constructor(errorName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Error ${errorName ? `\"${errorName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiErrorSignatureNotFoundError extends BaseError {\n  override name = 'AbiErrorSignatureNotFoundError'\n\n  signature: Hex\n\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded error signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n    this.signature = signature\n  }\n}\n\nexport class AbiEventSignatureEmptyTopicsError extends BaseError {\n  override name = 'AbiEventSignatureEmptyTopicsError'\n  constructor({ docsPath }: { docsPath: string }) {\n    super('Cannot extract event signature from empty topics.', {\n      docsPath,\n    })\n  }\n}\n\nexport class AbiEventSignatureNotFoundError extends BaseError {\n  override name = 'AbiEventSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded event signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiEventNotFoundError extends BaseError {\n  override name = 'AbiEventNotFoundError'\n  constructor(eventName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Event ${eventName ? `\"${eventName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the event exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionNotFoundError extends BaseError {\n  override name = 'AbiFunctionNotFoundError'\n  constructor(functionName?: string, { docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        `Function ${functionName ? `\"${functionName}\" ` : ''}not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionOutputsNotFoundError extends BaseError {\n  override name = 'AbiFunctionOutputsNotFoundError'\n  constructor(functionName: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Function \"${functionName}\" does not contain any \\`outputs\\` on ABI.`,\n        'Cannot decode function result without knowing what the parameter types are.',\n        'Make sure you are using the correct ABI and that the function exists on it.',\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class AbiFunctionSignatureNotFoundError extends BaseError {\n  override name = 'AbiFunctionSignatureNotFoundError'\n  constructor(signature: Hex, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Encoded function signature \"${signature}\" not found on ABI.`,\n        'Make sure you are using the correct ABI and that the function exists on it.',\n        `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ].join('\\n'),\n      {\n        docsPath,\n      },\n    )\n  }\n}\n\nexport class BytesSizeMismatchError extends BaseError {\n  override name = 'BytesSizeMismatchError'\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\nexport class DecodeLogDataMismatch extends BaseError {\n  override name = 'DecodeLogDataMismatch'\n\n  abiItem: AbiEvent\n  data: Hex\n  params: readonly AbiParameter[]\n  size: number\n\n  constructor({\n    abiItem,\n    data,\n    params,\n    size,\n  }: {\n    abiItem: AbiEvent\n    data: Hex\n    params: readonly AbiParameter[]\n    size: number\n  }) {\n    super(\n      [\n        `Data size of ${size} bytes is too small for non-indexed event parameters.`,\n      ].join('\\n'),\n      {\n        metaMessages: [\n          `Params: (${formatAbiParams(params, { includeName: true })})`,\n          `Data:   ${data} (${size} bytes)`,\n        ],\n      },\n    )\n\n    this.abiItem = abiItem\n    this.data = data\n    this.params = params\n    this.size = size\n  }\n}\n\nexport class DecodeLogTopicsMismatch extends BaseError {\n  override name = 'DecodeLogTopicsMismatch'\n\n  abiItem: AbiEvent\n\n  constructor({\n    abiItem,\n    param,\n  }: {\n    abiItem: AbiEvent\n    param: AbiParameter & { indexed: boolean }\n  }) {\n    super(\n      [\n        `Expected a topic for indexed event parameter${\n          param.name ? ` \"${param.name}\"` : ''\n        } on event \"${formatAbiItem(abiItem, { includeName: true })}\".`,\n      ].join('\\n'),\n    )\n\n    this.abiItem = abiItem\n  }\n}\n\nexport class InvalidAbiEncodingTypeError extends BaseError {\n  override name = 'InvalidAbiEncodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid encoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidAbiDecodingTypeError extends BaseError {\n  override name = 'InvalidAbiDecodingType'\n  constructor(type: string, { docsPath }: { docsPath: string }) {\n    super(\n      [\n        `Type \"${type}\" is not a valid decoding type.`,\n        'Please provide a valid ABI type.',\n      ].join('\\n'),\n      { docsPath },\n    )\n  }\n}\n\nexport class InvalidArrayError extends BaseError {\n  override name = 'InvalidArrayError'\n  constructor(value: unknown) {\n    super([`Value \"${value}\" is not a valid array.`].join('\\n'))\n  }\n}\n\nexport class InvalidDefinitionTypeError extends BaseError {\n  override name = 'InvalidDefinitionTypeError'\n  constructor(type: string) {\n    super(\n      [\n        `\"${type}\" is not a valid definition type.`,\n        'Valid types: \"function\", \"event\", \"error\"',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport class UnsupportedPackedAbiType extends BaseError {\n  override name = 'UnsupportedPackedAbiType'\n  constructor(type: unknown) {\n    super(`Type \"${type}\" is not supported for packed encoding.`)\n  }\n}\n", "import { SliceOffsetOutOfBoundsError } from '../../errors/data.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\n\nimport { isHex } from './isHex.js'\nimport { size } from './size.js'\n\nexport type SliceReturnType<TValue extends ByteArray | Hex> = TValue extends Hex\n  ? Hex\n  : ByteArray\n\n/**\n * @description Returns a section of the hex or byte array given a start/end bytes offset.\n *\n * @param value The hex or byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function slice<TValue extends ByteArray | Hex>(\n  value: TValue,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): SliceReturnType<TValue> {\n  if (isHex(value, { strict: false }))\n    return sliceHex(value as Hex, start, end, {\n      strict,\n    }) as SliceReturnType<TValue>\n  return sliceBytes(value as ByteArray, start, end, {\n    strict,\n  }) as SliceReturnType<TValue>\n}\n\nfunction assertStartOffset(value: Hex | ByteArray, start?: number) {\n  if (typeof start === 'number' && start > 0 && start > size(value) - 1)\n    throw new SliceOffsetOutOfBoundsError({\n      offset: start,\n      position: 'start',\n      size: size(value),\n    })\n}\n\nfunction assertEndOffset(value: Hex | ByteArray, start?: number, end?: number) {\n  if (\n    typeof start === 'number' &&\n    typeof end === 'number' &&\n    size(value) !== end - start\n  ) {\n    throw new SliceOffsetOutOfBoundsError({\n      offset: end,\n      position: 'end',\n      size: size(value),\n    })\n  }\n}\n\n/**\n * @description Returns a section of the byte array given a start/end bytes offset.\n *\n * @param value The byte array to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceBytes(\n  value_: ByteArray,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): ByteArray {\n  assertStartOffset(value_, start)\n  const value = value_.slice(start, end)\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n\n/**\n * @description Returns a section of the hex value given a start/end bytes offset.\n *\n * @param value The hex value to slice.\n * @param start The start offset (in bytes).\n * @param end The end offset (in bytes).\n */\nexport function sliceHex(\n  value_: Hex,\n  start?: number,\n  end?: number,\n  { strict }: { strict?: boolean } = {},\n): Hex {\n  assertStartOffset(value_, start)\n  const value = `0x${value_\n    .replace('0x', '')\n    .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}` as const\n  if (strict) assertEndOffset(value, start, end)\n  return value\n}\n", "const paramsRegex = /((function|event)\\s)?(.*)(\\((.*)\\))/\n\nexport function extractFunctionParts(def: string) {\n  const parts = def.match(paramsRegex)\n  const type = parts?.[2] || undefined\n  const name = parts?.[3]\n  const params = parts?.[5] || undefined\n  return { type, name, params }\n}\n\nexport function extractFunctionName(def: string) {\n  return extractFunctionParts(def).name\n}\n\nexport function extractFunctionParams(def: string) {\n  const params = extractFunctionParts(def).params\n  const splitParams = params?.split(',').map((x) => x.trim().split(' '))\n  return splitParams?.map((param) => ({\n    type: param[0],\n    name: param[1] === 'indexed' ? param[2] : param[1],\n    ...(param[1] === 'indexed' ? { indexed: true } : {}),\n  }))\n}\n\nexport function extractFunctionType(def: string) {\n  return extractFunctionParts(def).type\n}\n", "export function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nexport function bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\nexport function bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nexport function hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nexport function exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexport function output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output,\n};\n\nexport default assert;\n", "const U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nexport function split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nexport const toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h: number, l: number) => l;\nconst rotr32L = (h: number, l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "declare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use `globalThis.crypto`, but node.js versions earlier than v19 don't\n// declare it in global scope. For node.js, package.json#exports field mapping\n// rewrites import from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'\n */\nexport function bytesToHex(uint8a: Uint8Array): string {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') {\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);\n  }\n  return new TextEncoder().encode(str);\n}\n\nexport type Input = Uint8Array | string;\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n  return data;\n}\n\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  if (!arrays.every((a) => a instanceof Uint8Array)) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new TypeError('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashConstructor: () => Hash<T>) {\n  const hashC = (message: Input): Uint8Array => hashConstructor().update(toBytes(message)).digest();\n  const tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashConstructor();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\nconst rotlL = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    assert.number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    assert.exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructorWithOpts<Keccak, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\nexport const shake256 = genShake(0x1f, 136, 256 / 8);\n", "import { keccak_256 } from '@noble/hashes/sha3'\n\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isHex } from '../data/isHex.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Keccak256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport function keccak256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo,\n): Keccak256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = keccak_256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Keccak256Hash<TTo>\n  return toHex(bytes) as Keccak256Hash<TTo>\n}\n", "import {\n  extractFunctionName,\n  extractFunctionParams,\n} from '../contract/extractFunctionParts.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport type { AbiEvent, AbiFunction } from 'abitype'\n\nimport { keccak256 } from './keccak256.js'\n\nconst hash = (value: string) => keccak256(toBytes(value))\n\nexport function hashFunction(def: string) {\n  const name = extractFunctionName(def)\n  const params = extractFunctionParams(def) || []\n  return hash(`${name}(${params.map(({ type }) => type).join(',')})`)\n}\n\nexport function hashAbiItem(def: AbiFunction | AbiEvent) {\n  return hash(`${def.name}(${def.inputs.map(({ type }) => type).join(',')})`)\n}\n", "import { slice } from '../data/slice.js'\nimport type { AbiFunction } from 'abitype'\n\nimport { hashAbiItem, hashFunction } from './hashFunction.js'\n\nexport const getFunctionSelector = (fn: string | AbiFunction) => {\n  if (typeof fn === 'string') return slice(hashFunction(fn), 0, 4)\n  return slice(hashAbiItem(fn), 0, 4)\n}\n", "import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { stringToBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function checksumAddress(address_: Address, chainId?: number): Address {\n  const hexAddress = chainId\n    ? `${chainId}${address_.toLowerCase()}`\n    : address_.substring(2).toLowerCase()\n  const hash = keccak256(stringToBytes(hexAddress), 'bytes')\n\n  const address = (\n    chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress\n  ).split('')\n  for (let i = 0; i < 40; i += 2) {\n    if (hash[i >> 1] >> 4 >= 8 && address[i]) {\n      address[i] = address[i].toUpperCase()\n    }\n    if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {\n      address[i + 1] = address[i + 1].toUpperCase()\n    }\n  }\n\n  return `0x${address.join('')}`\n}\n\nexport function getAddress(address: string, chainId?: number): Address {\n  if (!isAddress(address)) throw new InvalidAddressError({ address })\n  return checksumAddress(address, chainId)\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiEncodingArrayLengthMismatchError,\n  AbiEncodingBytesSizeMismatchError,\n  AbiEncodingLengthMismatchError,\n  InvalidAbiEncodingTypeError,\n  InvalidArrayError,\n} from '../../errors/abi.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport type { Hex } from '../../types/misc.js'\nimport { isAddress } from '../address/isAddress.js'\nimport { concat } from '../data/concat.js'\nimport { padHex } from '../data/pad.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { boolToHex, numberToHex, stringToHex } from '../encoding/toHex.js'\n\nexport type EncodeAbiParametersReturnType = Hex\n\n/**\n * @description Encodes a list of primitive values into an ABI-encoded hex value.\n */\nexport function encodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(\n  params: Narrow<TParams>,\n  values: TParams extends readonly AbiParameter[]\n    ? AbiParametersToPrimitiveTypes<TParams>\n    : never,\n): EncodeAbiParametersReturnType {\n  if (params.length !== values.length)\n    throw new AbiEncodingLengthMismatchError({\n      expectedLength: params.length as number,\n      givenLength: values.length,\n    })\n  // Prepare the parameters to determine dynamic types to encode.\n  const preparedParams = prepareParams({\n    params: params as readonly AbiParameter[],\n    values,\n  })\n  const data = encodeParams(preparedParams)\n  if (data.length === 0) return '0x'\n  return data\n}\n\n/////////////////////////////////////////////////////////////////\n\ntype PreparedParam = { dynamic: boolean; encoded: Hex }\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\ntype Tuple = AbiParameterToPrimitiveType<TupleAbiParameter>\n\nfunction prepareParams<TParams extends readonly AbiParameter[]>({\n  params,\n  values,\n}: {\n  params: Narrow<TParams>\n  values: AbiParametersToPrimitiveTypes<TParams>\n}) {\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < params.length; i++) {\n    preparedParams.push(prepareParam({ param: params[i], value: values[i] }))\n  }\n  return preparedParams\n}\n\nfunction prepareParam<TParam extends AbiParameter>({\n  param,\n  value,\n}: {\n  param: TParam\n  value: AbiParameterToPrimitiveType<TParam>\n}): PreparedParam {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return encodeArray(value, { length, param: { ...param, type } })\n  }\n  if (param.type === 'tuple') {\n    return encodeTuple(value as unknown as Tuple, {\n      param: param as TupleAbiParameter,\n    })\n  }\n  if (param.type === 'address') {\n    return encodeAddress(value as unknown as Hex)\n  }\n  if (param.type === 'bool') {\n    return encodeBool(value as unknown as boolean)\n  }\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    const signed = param.type.startsWith('int')\n    return encodeNumber(value as unknown as number, { signed })\n  }\n  if (param.type.startsWith('bytes')) {\n    return encodeBytes(value as unknown as Hex, { param })\n  }\n  if (param.type === 'string') {\n    return encodeString(value as unknown as string)\n  }\n  throw new InvalidAbiEncodingTypeError(param.type, {\n    docsPath: '/docs/contract/encodeAbiParameters',\n  })\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeParams(preparedParams: PreparedParam[]): Hex {\n  // 1. Compute the size of the static part of the parameters.\n  let staticSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) staticSize += 32\n    else staticSize += size(encoded)\n  }\n\n  // 2. Split the parameters into static and dynamic parts.\n  const staticParams: Hex[] = []\n  const dynamicParams: Hex[] = []\n  let dynamicSize = 0\n  for (let i = 0; i < preparedParams.length; i++) {\n    const { dynamic, encoded } = preparedParams[i]\n    if (dynamic) {\n      staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }))\n      dynamicParams.push(encoded)\n      dynamicSize += size(encoded)\n    } else {\n      staticParams.push(encoded)\n    }\n  }\n\n  // 3. Concatenate static and dynamic parts.\n  return concat([...staticParams, ...dynamicParams])\n}\n\n/////////////////////////////////////////////////////////////////\n\nfunction encodeAddress(value: Hex): PreparedParam {\n  if (!isAddress(value)) throw new InvalidAddressError({ address: value })\n  return { dynamic: false, encoded: padHex(value.toLowerCase() as Hex) }\n}\n\nfunction encodeArray<TParam extends AbiParameter>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  {\n    length,\n    param,\n  }: {\n    length: number | null\n    param: TParam\n  },\n): PreparedParam {\n  const dynamic = length === null\n\n  if (!Array.isArray(value)) throw new InvalidArrayError(value)\n  if (!dynamic && value.length !== length)\n    throw new AbiEncodingArrayLengthMismatchError({\n      expectedLength: length!,\n      givenLength: value.length,\n      type: `${param.type}[${length}]`,\n    })\n\n  let dynamicChild = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < value.length; i++) {\n    const preparedParam = prepareParam({ param, value: value[i] })\n    if (preparedParam.dynamic) dynamicChild = true\n    preparedParams.push(preparedParam)\n  }\n\n  if (dynamic || dynamicChild) {\n    const data = encodeParams(preparedParams)\n    if (dynamic) {\n      const length = numberToHex(preparedParams.length, { size: 32 })\n      return {\n        dynamic: true,\n        encoded: preparedParams.length > 0 ? concat([length, data]) : length,\n      }\n    }\n    if (dynamicChild) return { dynamic: true, encoded: data }\n  }\n  return {\n    dynamic: false,\n    encoded: concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nfunction encodeBytes<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n): PreparedParam {\n  const [_, size_] = param.type.split('bytes')\n  if (!size_) {\n    const partsLength = Math.ceil(size(value) / 32)\n    const parts: Hex[] = []\n    for (let i = 0; i < partsLength; i++) {\n      parts.push(\n        padHex(slice(value, i * 32, (i + 1) * 32), {\n          dir: 'right',\n        }),\n      )\n    }\n    return {\n      dynamic: true,\n      encoded: concat([\n        padHex(numberToHex(size(value), { size: 32 })),\n        ...parts,\n      ]),\n    }\n  }\n  if (size(value) !== parseInt(size_))\n    throw new AbiEncodingBytesSizeMismatchError({\n      expectedSize: parseInt(size_),\n      value,\n    })\n  return { dynamic: false, encoded: padHex(value, { dir: 'right' }) }\n}\n\nfunction encodeBool(value: boolean): PreparedParam {\n  return { dynamic: false, encoded: padHex(boolToHex(value)) }\n}\n\nfunction encodeNumber(\n  value: number,\n  { signed }: { signed: boolean },\n): PreparedParam {\n  return {\n    dynamic: false,\n    encoded: numberToHex(value, {\n      size: 32,\n      signed,\n    }),\n  }\n}\n\nfunction encodeString(value: string): PreparedParam {\n  const hexValue = stringToHex(value)\n  const partsLength = Math.ceil(size(hexValue) / 32)\n  const parts: Hex[] = []\n  for (let i = 0; i < partsLength; i++) {\n    parts.push(\n      padHex(slice(hexValue, i * 32, (i + 1) * 32), {\n        dir: 'right',\n      }),\n    )\n  }\n  return {\n    dynamic: true,\n    encoded: concat([\n      padHex(numberToHex(size(hexValue), { size: 32 })),\n      ...parts,\n    ]),\n  }\n}\n\nfunction encodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(\n  value: AbiParameterToPrimitiveType<TParam>,\n  { param }: { param: TParam },\n): PreparedParam {\n  let dynamic = false\n  const preparedParams: PreparedParam[] = []\n  for (let i = 0; i < param.components.length; i++) {\n    const param_ = param.components[i]\n    const index = Array.isArray(value) ? i : param_.name\n    const preparedParam = prepareParam({\n      param: param_,\n      value: (value as any)[index!] as readonly unknown[],\n    })\n    preparedParams.push(preparedParam)\n    if (preparedParam.dynamic) dynamic = true\n  }\n  return {\n    dynamic,\n    encoded: dynamic\n      ? encodeParams(preparedParams)\n      : concat(preparedParams.map(({ encoded }) => encoded)),\n  }\n}\n\nexport function getArrayComponents(\n  type: string,\n): [length: number | null, innerType: string] | undefined {\n  const matches = type.match(/^(.*)\\[(\\d+)?\\]$/)\n  return matches\n    ? // Return `null` if the array is dynamic.\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\n    : undefined\n}\n", "import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n  Narrow,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiDecodingZeroDataError,\n  InvalidAbiDecodingTypeError,\n} from '../../errors/abi.js'\nimport type { Hex } from '../../types/misc.js'\nimport { checksumAddress } from '../address/getAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { trim } from '../data/trim.js'\nimport {\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from '../encoding/fromHex.js'\n\nimport { getArrayComponents } from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport function decodeAbiParameters<\n  TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: Narrow<TParams>, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && (params as unknown[]).length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\nfunction decodeParams<TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  const decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data))\n      throw new AbiDecodingDataSizeTooSmallError({\n        data,\n        params,\n        size: size(data),\n      })\n\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  const value = slice(data, position, position + 32, { strict: true }) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\nfunction decodeArray<TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Get the length of the array from the offset.\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(\n        slice(data, position, position + 32, { strict: true }),\n      )\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  const value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\nfunction decodeBytes<TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n    // If there is no length, we have zero data.\n    if (length === 0) return { consumed: 32, value: '0x' }\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true,\n    })\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true,\n  })\n  return { consumed: 32, value }\n}\n\nfunction decodeNumber<TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(\n    slice(data, position, position + 32, { strict: true }),\n  )\n  const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }))\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return { consumed: 32, value: '' }\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length, { strict: true })),\n  )\n  return { consumed: 32, value }\n}\n\nfunction decodeTuple<\n  TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n", "import type {\n  Abi,\n  ExtractAbiError,\n  ExtractAbiErrorNames,\n  Narrow,\n} from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  AbiErrorSignatureNotFoundError,\n} from '../../errors/abi.js'\nimport type { AbiItem, GetErrorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { slice } from '../data/slice.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = { abi?: Narrow<TAbi>; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  _ErrorNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiErrorNames<TAbi>\n    : string,\n> = {\n  [TName in _ErrorNames]: {\n    abiItem: TAbi extends Abi ? ExtractAbiError<TAbi, TName> : AbiItem\n    args: GetErrorArgs<TAbi, TName>['args']\n    errorName: TName\n  }\n}[_ErrorNames]\n\nexport function decodeErrorResult<TAbi extends Abi | readonly unknown[]>({\n  abi,\n  data,\n}: DecodeErrorResultParameters<TAbi>): DecodeErrorResultReturnType<TAbi> {\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...((abi as Abi) || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n      ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<TAbi>\n}\n", "export const stringify: typeof JSON.stringify = (value, replacer, space) =>\n  JSON.stringify(\n    value,\n    (key, value_) => {\n      const value = typeof value_ === 'bigint' ? value_.toString() : value_\n      return typeof replacer === 'function' ? replacer(key, value) : value\n    },\n    space,\n  )\n", "import type { AbiParameter } from 'abitype'\n\nimport type { AbiItem } from '../../types/contract.js'\nimport { stringify } from '../stringify.js'\n\nexport function formatAbiItemWithArgs({\n  abiItem,\n  args,\n  includeFunctionName = true,\n  includeName = false,\n}: {\n  abiItem: AbiItem\n  args: readonly unknown[]\n  includeFunctionName?: boolean\n  includeName?: boolean\n}) {\n  if (!('name' in abiItem)) return\n  if (!('inputs' in abiItem)) return\n  if (!abiItem.inputs) return\n  return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs\n    .map(\n      (input: AbiParameter, i: number) =>\n        `${includeName && input.name ? `${input.name}: ` : ''}${\n          typeof args[i] === 'object' ? stringify(args[i]) : args[i]\n        }`,\n    )\n    .join(', ')})`\n}\n", "import type { Abi, AbiParameter, Address, Narrow } from 'abitype'\n\nimport type { GetFunctionArgs, InferItemName } from '../../types/contract.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport type GetAbiItemParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = {\n  abi: Narrow<TAbi>\n  name: InferItemName<TAbi, TItemName>\n} & Partial<GetFunctionArgs<TAbi, TItemName>>\n\nexport type GetAbiItemReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = Extract<\n  TAbi[number],\n  {\n    name: TItemName\n  }\n>\n\nexport function getAbiItem<\n  TAbi extends Abi | readonly unknown[],\n  TItemName extends string,\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<\n  TAbi,\n  TItemName\n> {\n  const abiItems = (abi as Abi).filter((x) => 'name' in x && x.name === name)\n\n  if (abiItems.length === 0) return undefined as any\n  if (abiItems.length === 1) return abiItems[0] as any\n\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem as any\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = (args as readonly unknown[]).every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter as AbiParameter)\n    })\n    if (matched) return abiItem as any\n  }\n  return abiItems[0] as any\n}\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address)\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { parseAccount } from '../accounts/utils/parseAccount.js'\nimport type { CallParameters } from '../actions/public/call.js'\nimport { panicReasons } from '../constants/solidity.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\nimport {\n  type DecodeErrorResultReturnType,\n  decodeErrorResult,\n} from '../utils/abi/decodeErrorResult.js'\nimport { formatAbiItem } from '../utils/abi/formatAbiItem.js'\nimport { formatAbiItemWithArgs } from '../utils/abi/formatAbiItemWithArgs.js'\nimport { getAbiItem } from '../utils/abi/getAbiItem.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { AbiErrorSignatureNotFoundError } from './abi.js'\nimport { BaseError } from './base.js'\nimport { prettyPrint } from './transaction.js'\nimport { getContractAddress } from './utils.js'\n\nexport class CallExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'CallExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account: account_,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: CallParameters & { chain?: Chain; docsPath?: string },\n  ) {\n    const account = account_ ? parseAccount(account_) : undefined\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Raw Call Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport class ContractFunctionExecutionError extends BaseError {\n  abi: Abi\n  args?: unknown[]\n  override cause: BaseError\n  contractAddress?: Address\n  formattedArgs?: string\n  functionName: string\n  sender?: Address\n\n  override name = 'ContractFunctionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      abi,\n      args,\n      contractAddress,\n      docsPath,\n      functionName,\n      sender,\n    }: {\n      abi: Abi\n      args?: any\n      contractAddress?: Address\n      docsPath?: string\n      functionName: string\n      sender?: Address\n    },\n  ) {\n    const abiItem = getAbiItem({ abi, args, name: functionName })\n    const formattedArgs = abiItem\n      ? formatAbiItemWithArgs({\n          abiItem,\n          args,\n          includeFunctionName: false,\n          includeName: false,\n        })\n      : undefined\n    const functionWithParams = abiItem\n      ? formatAbiItem(abiItem, { includeName: true })\n      : undefined\n\n    const prettyArgs = prettyPrint({\n      address: contractAddress && getContractAddress(contractAddress),\n      function: functionWithParams,\n      args:\n        formattedArgs &&\n        formattedArgs !== '()' &&\n        `${[...Array(functionName?.length ?? 0).keys()]\n          .map(() => ' ')\n          .join('')}${formattedArgs}`,\n      sender,\n    })\n\n    super(\n      cause.shortMessage ||\n        `An unknown error occurred while executing the contract function \"${functionName}\".`,\n      {\n        cause,\n        docsPath,\n        metaMessages: [\n          ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n          'Contract Call:',\n          prettyArgs,\n        ].filter(Boolean) as string[],\n      },\n    )\n    this.abi = abi\n    this.args = args\n    this.cause = cause\n    this.contractAddress = contractAddress\n    this.functionName = functionName\n    this.sender = sender\n  }\n}\n\nexport class ContractFunctionRevertedError extends BaseError {\n  override name = 'ContractFunctionRevertedError'\n\n  data?: DecodeErrorResultReturnType\n  reason?: string\n  signature?: Hex\n\n  constructor({\n    abi,\n    data,\n    functionName,\n    message,\n  }: { abi: Abi; data?: Hex; functionName: string; message?: string }) {\n    let cause: Error | undefined\n    let decodedData: DecodeErrorResultReturnType | undefined = undefined\n    let metaMessages\n    let reason\n    if (data && data !== '0x') {\n      try {\n        decodedData = decodeErrorResult({ abi, data })\n        const { abiItem, errorName, args: errorArgs } = decodedData\n        if (errorName === 'Error') {\n          reason = (errorArgs as [string])[0]\n        } else if (errorName === 'Panic') {\n          const [firstArg] = errorArgs as [number]\n          reason = panicReasons[firstArg as keyof typeof panicReasons]\n        } else {\n          const errorWithParams = abiItem\n            ? formatAbiItem(abiItem, { includeName: true })\n            : undefined\n          const formattedArgs =\n            abiItem && errorArgs\n              ? formatAbiItemWithArgs({\n                  abiItem,\n                  args: errorArgs,\n                  includeFunctionName: false,\n                  includeName: false,\n                })\n              : undefined\n\n          metaMessages = [\n            errorWithParams ? `Error: ${errorWithParams}` : '',\n            formattedArgs && formattedArgs !== '()'\n              ? `       ${[...Array(errorName?.length ?? 0).keys()]\n                  .map(() => ' ')\n                  .join('')}${formattedArgs}`\n              : '',\n          ]\n        }\n      } catch (err) {\n        cause = err as Error\n      }\n    } else if (message) reason = message\n\n    let signature: Hex | undefined\n    if (cause instanceof AbiErrorSignatureNotFoundError) {\n      signature = cause.signature\n      metaMessages = [\n        `Unable to decode signature \"${signature}\" as it was not found on the provided ABI.`,\n        'Make sure you are using the correct ABI and that the error exists on it.',\n        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,\n      ]\n    }\n\n    super(\n      (reason && reason !== 'execution reverted') || signature\n        ? [\n            `The contract function \"${functionName}\" reverted with the following ${\n              signature ? 'signature' : 'reason'\n            }:`,\n            reason || signature,\n          ].join('\\n')\n        : `The contract function \"${functionName}\" reverted.`,\n      {\n        cause,\n        metaMessages,\n      },\n    )\n\n    this.data = decodedData\n    this.reason = reason\n    this.signature = signature\n  }\n}\n\nexport class ContractFunctionZeroDataError extends BaseError {\n  override name = 'ContractFunctionZeroDataError'\n  constructor({ functionName }: { functionName: string }) {\n    super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\n      metaMessages: [\n        'This could be due to any of the following:',\n        `  - The contract does not have the function \"${functionName}\",`,\n        '  - The parameters passed to the contract function may be invalid, or',\n        '  - The address is not a contract.',\n      ],\n    })\n  }\n}\n\nexport class RawContractError extends BaseError {\n  code = 3\n  override name = 'RawContractError'\n\n  data?: Hex | { data?: Hex }\n\n  constructor({\n    data,\n    message,\n  }: { data?: Hex | { data?: Hex }; message?: string }) {\n    super(message || '')\n    this.data = data\n  }\n}\n", "import type { Abi, ExtractAbiFunctionNames, Narrow } from 'abitype'\n\nimport {\n  AbiFunctionNotFoundError,\n  AbiFunctionOutputsNotFoundError,\n} from '../../errors/abi.js'\nimport type {\n  AbiItem,\n  ContractFunctionResult,\n  GetFunctionArgs,\n  InferFunctionName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/decodeFunctionResult'\n\nexport type DecodeFunctionResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName = InferFunctionName<TAbi, TFunctionName>,\n> = {\n  functionName?: _FunctionName\n  data: Hex\n} & (TFunctionName extends string\n  ? { abi: Narrow<TAbi> } & Partial<GetFunctionArgs<TAbi, TFunctionName>>\n  : _FunctionName extends string\n  ? { abi: [Narrow<TAbi[number]>] } & Partial<\n      GetFunctionArgs<TAbi, _FunctionName>\n    >\n  : never)\n\nexport type DecodeFunctionResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiFunctionNames<TAbi>[number]\n    : string,\n> = TFunctionName extends string\n  ? ContractFunctionResult<TAbi, TFunctionName>\n  : ContractFunctionResult<TAbi, _FunctionName>\n\nexport function decodeFunctionResult<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = undefined,\n>({\n  abi,\n  args,\n  functionName,\n  data,\n}: DecodeFunctionResultParameters<\n  TAbi,\n  TFunctionName\n>): DecodeFunctionResultReturnType<TAbi, TFunctionName> {\n  let abiItem = abi[0] as AbiItem\n  if (functionName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    } as GetAbiItemParameters)\n    if (!abiItem) throw new AbiFunctionNotFoundError(functionName, { docsPath })\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, { docsPath })\n  if (!abiItem.outputs)\n    throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath })\n\n  const values = decodeAbiParameters(abiItem.outputs, data)\n  if (values && values.length > 1) return values as any\n  if (values && values.length === 1) return values[0] as any\n  return undefined as any\n}\n", "import type { Abi, Narrow } from 'abitype'\n\nimport { AbiFunctionNotFoundError } from '../../errors/abi.js'\nimport type {\n  AbiItem,\n  GetFunctionArgs,\n  InferFunctionName,\n} from '../../types/contract.js'\nimport { concatHex } from '../data/concat.js'\nimport { getFunctionSelector } from '../hash/getFunctionSelector.js'\n\nimport { encodeAbiParameters } from './encodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nexport type EncodeFunctionDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string | undefined = string,\n  _FunctionName = InferFunctionName<TAbi, TFunctionName>,\n> = {\n  functionName?: _FunctionName\n} & (TFunctionName extends string\n  ? { abi: Narrow<TAbi> } & GetFunctionArgs<TAbi, TFunctionName>\n  : _FunctionName extends string\n  ? { abi: [Narrow<TAbi[number]>] } & GetFunctionArgs<TAbi, _FunctionName>\n  : never)\n\nexport function encodeFunctionData<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string | undefined = undefined,\n>({\n  abi,\n  args,\n  functionName,\n}: EncodeFunctionDataParameters<TAbi, TFunctionName>) {\n  let abiItem = abi[0] as AbiItem\n  if (functionName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: functionName,\n    } as GetAbiItemParameters)\n    if (!abiItem)\n      throw new AbiFunctionNotFoundError(functionName, {\n        docsPath: '/docs/contract/encodeFunctionData',\n      })\n  }\n\n  if (abiItem.type !== 'function')\n    throw new AbiFunctionNotFoundError(undefined, {\n      docsPath: '/docs/contract/encodeFunctionData',\n    })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = getFunctionSelector(definition)\n  const data =\n    'inputs' in abiItem && abiItem.inputs\n      ? encodeAbiParameters(abiItem.inputs, (args ?? []) as readonly unknown[])\n      : undefined\n  return concatHex([signature, data ?? '0x'])\n}\n", "import { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport class HttpRequestError extends BaseError {\n  override name = 'HttpRequestError'\n\n  body?: { [x: string]: unknown } | { [y: string]: unknown }[]\n  headers?: Headers\n  status?: number\n  url: string\n\n  constructor({\n    body,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body?: { [x: string]: unknown } | { [y: string]: unknown }[]\n    details?: string\n    headers?: Headers\n    status?: number\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport class WebSocketRequestError extends BaseError {\n  override name = 'WebSocketRequestError'\n\n  constructor({\n    body,\n    details,\n    url,\n  }: {\n    body: { [key: string]: unknown }\n    details: string\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      details,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n\nexport class RpcRequestError extends BaseError {\n  override name = 'RpcRequestError'\n\n  code: number\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n    this.code = error.code\n  }\n}\n\nexport class TimeoutError extends BaseError {\n  override name = 'TimeoutError'\n\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n    })\n  }\n}\n", "import type { Prettify } from '../types/utils.js'\nimport { BaseError } from './base.js'\nimport { RpcRequestError } from './request.js'\n\nconst unknownErrorCode = -1\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042 // Method not found\n\ntype RpcErrorOptions<TCode extends number = RpcErrorCode> = {\n  code?: TCode | (number & {})\n  docsPath?: string\n  metaMessages?: string[]\n  shortMessage: string\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1474\n */\nexport class RpcError<TCode extends number = RpcErrorCode> extends BaseError {\n  override name = 'RpcError'\n\n  code: TCode | (number & {})\n\n  constructor(\n    cause: Error,\n    { code, docsPath, metaMessages, shortMessage }: RpcErrorOptions<TCode>,\n  ) {\n    super(shortMessage, {\n      cause,\n      docsPath,\n      metaMessages:\n        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n    })\n    this.name = cause.name\n    this.code = (\n      cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode\n    ) as TCode\n  }\n}\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902 // Chain Not Recongnized\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1193\n */\nexport class ProviderRpcError<\n  T = undefined,\n> extends RpcError<ProviderRpcErrorCode> {\n  override name = 'ProviderRpcError'\n\n  data?: T\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T\n      }\n    >,\n  ) {\n    super(cause, options)\n\n    this.data = options.data\n  }\n}\n\n/**\n * Subclass for a \"Parse error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ParseRpcError extends RpcError {\n  override name = 'ParseRpcError'\n  static code = -32700 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ParseRpcError.code,\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Invalid request\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidRequestRpcError extends RpcError {\n  override name = 'InvalidRequestRpcError'\n  static code = -32600 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidRequestRpcError.code,\n      shortMessage: 'JSON is not a valid request object.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class MethodNotFoundRpcError extends RpcError {\n  override name = 'MethodNotFoundRpcError'\n  static code = -32601 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: MethodNotFoundRpcError.code,\n      shortMessage: 'The method does not exist / is not available.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid params\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidParamsRpcError extends RpcError {\n  override name = 'InvalidParamsRpcError'\n  static code = -32602 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidParamsRpcError.code,\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for an \"Internal error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InternalRpcError extends RpcError {\n  override name = 'InternalRpcError'\n  static code = -32603 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InternalRpcError.code,\n      shortMessage: 'An internal error was received.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid input\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class InvalidInputRpcError extends RpcError {\n  override name = 'InvalidInputRpcError'\n  static code = -32000 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidInputRpcError.code,\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ResourceNotFoundRpcError extends RpcError {\n  override name = 'ResourceNotFoundRpcError'\n  static code = -32001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceNotFoundRpcError.code,\n      shortMessage: 'Requested resource not found.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource unavailable\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class ResourceUnavailableRpcError extends RpcError {\n  override name = 'ResourceUnavailableRpcError'\n  static code = -32002 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceUnavailableRpcError.code,\n      shortMessage: 'Requested resource not available.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Transaction rejected\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class TransactionRejectedRpcError extends RpcError {\n  override name = 'TransactionRejectedRpcError'\n  static code = -32003 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: TransactionRejectedRpcError.code,\n      shortMessage: 'Transaction creation failed.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class MethodNotSupportedRpcError extends RpcError {\n  override name = 'MethodNotSupportedRpcError'\n  static code = -32004 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: MethodNotSupportedRpcError.code,\n      shortMessage: 'Method is not implemented.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Limit exceeded\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class LimitExceededRpcError extends RpcError {\n  override name = 'LimitExceededRpcError'\n  static code = -32005 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: LimitExceededRpcError.code,\n      shortMessage: 'Request exceeds defined limit.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"JSON-RPC version not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n  override name = 'JsonRpcVersionUnsupportedError'\n  static code = -32006 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: JsonRpcVersionUnsupportedError.code,\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"User Rejected Request\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UserRejectedRequestError extends ProviderRpcError {\n  override name = 'UserRejectedRequestError'\n  static code = 4001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UserRejectedRequestError.code,\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  override name = 'UnauthorizedProviderError'\n  static code = 4100 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnauthorizedProviderError.code,\n      shortMessage:\n        'The requested method and/or account has not been authorized by the user.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  override name = 'UnsupportedProviderMethodError'\n  static code = 4200 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnsupportedProviderMethodError.code,\n      shortMessage: 'The Provider does not support the requested method.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  override name = 'ProviderDisconnectedError'\n  static code = 4900 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ProviderDisconnectedError.code,\n      shortMessage: 'The Provider is disconnected from all chains.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class ChainDisconnectedError extends ProviderRpcError {\n  override name = 'ChainDisconnectedError'\n  static code = 4901 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ChainDisconnectedError.code,\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport class SwitchChainError extends ProviderRpcError {\n  override name = 'SwitchChainError'\n  static code = 4902 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: SwitchChainError.code,\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport class UnknownRpcError extends RpcError {\n  override name = 'UnknownRpcError'\n\n  constructor(cause: Error) {\n    super(cause, {\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n", "import type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport {\n  ExecutionRevertedError,\n  FeeCapTooHighError,\n  FeeCapTooLowError,\n  InsufficientFundsError,\n  IntrinsicGasTooHighError,\n  IntrinsicGasTooLowError,\n  NonceMaxValueError,\n  NonceTooHighError,\n  NonceTooLowError,\n  TipAboveFeeCapError,\n  TransactionTypeNotSupportedError,\n  UnknownNodeError,\n} from '../../errors/node.js'\nimport { RpcRequestError } from '../../errors/request.js'\nimport {\n  InvalidInputRpcError,\n  TransactionRejectedRpcError,\n} from '../../errors/rpc.js'\n\nexport function containsNodeError(err: BaseError) {\n  return (\n    err instanceof TransactionRejectedRpcError ||\n    err instanceof InvalidInputRpcError ||\n    (err instanceof RpcRequestError && err.code === ExecutionRevertedError.code)\n  )\n}\n\nexport type GetNodeErrorParameters = Partial<SendTransactionParameters<any>>\n\nexport function getNodeError(err: BaseError, args: GetNodeErrorParameters) {\n  const message = err.details.toLowerCase()\n  if (FeeCapTooHighError.nodeMessage.test(message))\n    return new FeeCapTooHighError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (FeeCapTooLowError.nodeMessage.test(message))\n    return new FeeCapTooLowError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n    })\n  else if (NonceTooHighError.nodeMessage.test(message))\n    return new NonceTooHighError({ cause: err, nonce: args?.nonce })\n  else if (NonceTooLowError.nodeMessage.test(message))\n    return new NonceTooLowError({ cause: err, nonce: args?.nonce })\n  else if (NonceMaxValueError.nodeMessage.test(message))\n    return new NonceMaxValueError({ cause: err, nonce: args?.nonce })\n  else if (InsufficientFundsError.nodeMessage.test(message))\n    return new InsufficientFundsError({ cause: err })\n  else if (IntrinsicGasTooHighError.nodeMessage.test(message))\n    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas })\n  else if (IntrinsicGasTooLowError.nodeMessage.test(message))\n    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas })\n  else if (TransactionTypeNotSupportedError.nodeMessage.test(message))\n    return new TransactionTypeNotSupportedError({ cause: err })\n  else if (TipAboveFeeCapError.nodeMessage.test(message))\n    return new TipAboveFeeCapError({\n      cause: err,\n      maxFeePerGas: args?.maxFeePerGas,\n      maxPriorityFeePerGas: args?.maxPriorityFeePerGas,\n    })\n  else if (\n    message.match(ExecutionRevertedError.nodeMessage) ||\n    ('code' in (err.cause as BaseError) &&\n      (err.cause as { code: number })?.code === ExecutionRevertedError.code)\n  )\n    return new ExecutionRevertedError({\n      cause: err,\n      message: (err.cause as BaseError).details || err.details,\n    })\n  return new UnknownNodeError({\n    cause: (err.cause as BaseError).cause as BaseError,\n  })\n}\n", "import type { CallParameters } from '../../actions/public/call.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  containsNodeError,\n  getNodeError,\n} from './getNodeError.js'\n\nexport function getCallError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: CallParameters & {\n    chain?: Chain\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err))\n    cause = getNodeError(err, args as GetNodeErrorParameters)\n  return new CallExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n", "import type { Formatter } from '../../types/formatter.js'\n\n/**\n * @description Picks out the keys from `value` that exist in the formatter.\n */\nexport function extract(\n  value: Record<string, unknown>,\n  { format }: { format?: Formatter['format'] },\n) {\n  if (!format) return {}\n  const keys = Object.keys(format({}))\n  return keys.reduce((data: Record<string, unknown>, key) => {\n    // rome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (value?.hasOwnProperty(key)) {\n      data[key] = value[key]\n    }\n    return data\n  }, {})\n}\n", "type Resolved<TReturnType extends readonly unknown[] = any> = [\n  result: TReturnType[number],\n  results: TReturnType,\n]\n\ntype PendingPromise<TReturnType extends readonly unknown[] = any> = {\n  resolve?: (data: Resolved<TReturnType>) => void\n  reject?: (reason?: unknown) => void\n}\n\ntype SchedulerItem = { args: unknown; pendingPromise: PendingPromise }\n\nexport type CreateBatchSchedulerArguments<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  fn: (args: TParameters[]) => Promise<TReturnType>\n  id: number | string\n  shouldSplitBatch?: (args: TParameters[]) => boolean\n  wait?: number\n}\nexport type CreateBatchSchedulerReturnType<\n  TParameters = unknown,\n  TReturnType extends readonly unknown[] = readonly unknown[],\n> = {\n  flush: () => void\n  schedule: TParameters extends undefined\n    ? (args?: TParameters) => Promise<Resolved<TReturnType>>\n    : (args: TParameters) => Promise<Resolved<TReturnType>>\n}\n\nconst schedulerCache = /*#__PURE__*/ new Map<number | string, SchedulerItem[]>()\n\nexport function createBatchScheduler<\n  TParameters,\n  TReturnType extends readonly unknown[],\n>({\n  fn,\n  id,\n  shouldSplitBatch,\n  wait = 0,\n}: CreateBatchSchedulerArguments<\n  TParameters,\n  TReturnType\n>): CreateBatchSchedulerReturnType<TParameters, TReturnType> {\n  const exec = async () => {\n    const scheduler = getScheduler()\n    flush()\n\n    const args = scheduler.map(({ args }) => args)\n\n    if (args.length === 0) return\n\n    fn(args as TParameters[])\n      .then((data) => {\n        scheduler.forEach(({ pendingPromise }, i) =>\n          pendingPromise.resolve?.([data[i], data]),\n        )\n      })\n      .catch((err) => {\n        scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err))\n      })\n  }\n\n  const flush = () => schedulerCache.delete(id)\n\n  const getBatchedArgs = () =>\n    getScheduler().map(({ args }) => args) as TParameters[]\n\n  const getScheduler = () => schedulerCache.get(id) || []\n\n  const setScheduler = (item: SchedulerItem) =>\n    schedulerCache.set(id, [...getScheduler(), item])\n\n  return {\n    flush,\n    async schedule(args: TParameters) {\n      const pendingPromise: PendingPromise<TReturnType> = {}\n      const promise = new Promise<Resolved<TReturnType>>((resolve, reject) => {\n        pendingPromise.resolve = resolve\n        pendingPromise.reject = reject\n      })\n\n      const split = shouldSplitBatch?.([...getBatchedArgs(), args])\n\n      if (split) exec()\n\n      const hasActiveScheduler = getScheduler().length > 0\n      if (hasActiveScheduler) {\n        setScheduler({ args, pendingPromise })\n        return promise\n      }\n\n      setScheduler({ args, pendingPromise })\n      setTimeout(exec, wait)\n      return promise\n    },\n  } as unknown as CreateBatchSchedulerReturnType<TParameters, TReturnType>\n}\n", "import { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport { InvalidAddressError } from '../../errors/address.js'\nimport { FeeCapTooHighError, TipAboveFeeCapError } from '../../errors/node.js'\nimport { FeeConflictError } from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\nimport { isAddress } from '../address/isAddress.js'\n\nexport type AssertRequestParameters = Partial<SendTransactionParameters<Chain>>\n\nexport function assertRequest(args: AssertRequestParameters) {\n  const {\n    account: account_,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    to,\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n  if (account && !isAddress(account.address))\n    throw new InvalidAddressError({ address: account.address })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (\n    typeof gasPrice !== 'undefined' &&\n    (typeof maxFeePerGas !== 'undefined' ||\n      typeof maxPriorityFeePerGas !== 'undefined')\n  )\n    throw new FeeConflictError()\n\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getCallError } from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport type { AssertRequestParameters } from '../../utils/transaction/assertRequest.js'\n\nexport type FormattedCall<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionRequest<TChain>\n\nexport type CallParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedCall<TChain>, 'from'> & {\n  account?: Account | Address\n  batch?: boolean\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint\n        blockTag?: never\n      }\n    | {\n        blockNumber?: never\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag\n      }\n  )\n\nexport type CallReturnType = { data: Hex | undefined }\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call.html\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  args: CallParameters<TChain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const format =\n      client.chain?.formatters?.transactionRequest?.format ||\n      formatTransactionRequest\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format }),\n      from: account?.address,\n      accessList,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest) as TransactionRequest\n\n    if (batch && shouldPerformMulticall({ request })) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<TChain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: block\n        ? [request as Partial<RpcTransactionRequest>, block]\n        : [request as Partial<RpcTransactionRequest>],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (data?.slice(0, 10) === offchainLookupSignature && to) {\n      return { data: await offchainLookup(client, { data, to }) }\n    }\n    throw getCallError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<TChain extends Chain | undefined> = Pick<\n  CallParameters<TChain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address\n  to: Address\n}\n\nasync function scheduleMulticall<TChain extends Chain | undefined,>(\n  client: Client<Transport>,\n  args: ScheduleMulticallParameters<TChain>,\n) {\n  const { batchSize = 1024, wait = 0 } =\n    typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to,\n  } = args\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            data: calldata,\n            to: multicallAddress,\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error.data === 'object' ? error.data.data : error.data\n}\n", "import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport { InvalidAddressError } from '../../errors/address.js'\n\nimport { isAddress } from './isAddress.js'\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a)) throw new InvalidAddressError({ address: a })\n  if (!isAddress(b)) throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { GetErrorArgs } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport async function offchainLookup<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  }) as unknown as GetErrorArgs<\n    [typeof offchainLookupAbiItem],\n    'OffchainLookup'\n  >\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method =\n      url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],
  "mappings": "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",
  "names": ["docsPath", "size", "docsPath", "size", "docsPath", "hash", "toBytes", "toBytes", "toBytes", "bytes", "bytes", "hash", "hash", "length", "length", "consumed", "value", "size", "value", "docsPath", "docsPath", "docsPath", "args", "split", "data", "offchainLookup", "offchainLookupSignature", "args", "size"]
}
