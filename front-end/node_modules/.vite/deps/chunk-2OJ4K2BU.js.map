{
  "version": 3,
  "sources": ["../../eventemitter3/index.js", "../../@wagmi/connectors/dist/chunk-QYMCVNHT.js", "../../@wagmi/connectors/dist/chunk-ZCAPXGBX.js", "../../@wagmi/connectors/dist/chunk-OQILYQDO.js", "../../viem/src/errors/log.ts", "../../viem/src/utils/hash/getEventSelector.ts", "../../viem/src/utils/abi/encodeEventTopics.ts", "../../viem/src/utils/filters/createFilterRequestScope.ts", "../../viem/src/actions/public/createContractEventFilter.ts", "../../viem/src/utils/errors/getContractError.ts", "../../viem/src/errors/account.ts", "../../viem/src/errors/estimateGas.ts", "../../viem/src/utils/errors/getEstimateGasError.ts", "../../viem/src/errors/block.ts", "../../viem/src/actions/public/getBlock.ts", "../../viem/src/actions/public/getGasPrice.ts", "../../viem/src/actions/public/getTransactionCount.ts", "../../viem/src/utils/transaction/prepareRequest.ts", "../../viem/src/actions/public/estimateGas.ts", "../../viem/src/actions/public/estimateContractGas.ts", "../../viem/src/actions/public/readContract.ts", "../../viem/src/actions/public/simulateContract.ts", "../../viem/src/utils/observe.ts", "../../viem/src/utils/wait.ts", "../../viem/src/utils/poll.ts", "../../viem/src/utils/promise/withCache.ts", "../../viem/src/actions/public/getBlockNumber.ts", "../../viem/src/utils/abi/decodeEventLog.ts", "../../viem/src/actions/public/getFilterChanges.ts", "../../viem/src/actions/public/getLogs.ts", "../../viem/src/actions/public/uninstallFilter.ts", "../../viem/src/actions/public/watchContractEvent.ts", "../../viem/src/utils/errors/getTransactionError.ts", "../../viem/src/actions/public/getChainId.ts", "../../viem/src/actions/wallet/sendTransaction.ts", "../../viem/src/actions/wallet/writeContract.ts", "../../viem/src/actions/wallet/addChain.ts", "../../viem/src/utils/uid.ts", "../../viem/src/clients/createClient.ts", "../../viem/src/utils/promise/withRetry.ts", "../../viem/src/utils/buildRequest.ts", "../../viem/src/clients/transports/createTransport.ts", "../../viem/src/clients/transports/custom.ts", "../../viem/src/clients/transports/fallback.ts", "../../viem/src/errors/transport.ts", "../../viem/src/utils/promise/withTimeout.ts", "../../viem/src/utils/rpc.ts", "../../viem/src/clients/transports/http.ts", "../../viem/src/utils/ens/errors.ts", "../../viem/src/utils/regex.ts", "../../viem/src/utils/typedData.ts", "../../viem/src/utils/abi/encodeDeployData.ts", "../../viem/src/utils/signature/hashTypedData.ts", "../../viem/src/utils/signature/hashMessage.ts", "../../viem/src/utils/unit/parseUnits.ts", "../../viem/src/utils/unit/parseGwei.ts", "../../viem/src/utils/ens/encodedLabelToLabelhash.ts", "../../viem/src/utils/ens/namehash.ts", "../../viem/src/utils/ens/encodeLabelhash.ts", "../../viem/src/utils/ens/labelhash.ts", "../../viem/src/utils/ens/packetToBytes.ts", "../../viem/src/actions/ens/getEnsAddress.ts", "../../viem/src/errors/ens.ts", "../../viem/src/utils/ens/avatar/utils.ts", "../../viem/src/utils/ens/avatar/parseAvatarRecord.ts", "../../viem/src/actions/ens/getEnsText.ts", "../../viem/src/actions/ens/getEnsAvatar.ts", "../../viem/src/actions/ens/getEnsName.ts", "../../viem/src/actions/ens/getEnsResolver.ts", "../../viem/src/actions/public/createBlockFilter.ts", "../../viem/src/actions/public/createEventFilter.ts", "../../viem/src/actions/public/createPendingTransactionFilter.ts", "../../viem/src/actions/public/getBalance.ts", "../../viem/src/actions/public/getBlockTransactionCount.ts", "../../viem/src/actions/public/getBytecode.ts", "../../viem/src/utils/formatters/feeHistory.ts", "../../viem/src/actions/public/getFeeHistory.ts", "../../viem/src/actions/public/getFilterLogs.ts", "../../viem/src/actions/public/getStorageAt.ts", "../../viem/src/actions/public/getTransaction.ts", "../../viem/src/actions/public/getTransactionConfirmations.ts", "../../viem/src/actions/public/getTransactionReceipt.ts", "../../viem/src/actions/public/multicall.ts", "../../viem/src/constants/contracts.ts", "../../viem/src/utils/data/isBytesEqual.ts", "../../viem/src/actions/public/verifyHash.ts", "../../viem/src/actions/public/verifyMessage.ts", "../../viem/src/actions/public/verifyTypedData.ts", "../../viem/src/actions/public/watchBlockNumber.ts", "../../viem/src/actions/public/waitForTransactionReceipt.ts", "../../viem/src/actions/public/watchBlocks.ts", "../../viem/src/actions/public/watchEvent.ts", "../../viem/src/actions/public/watchPendingTransactions.ts", "../../viem/src/clients/decorators/public.ts", "../../viem/src/clients/createPublicClient.ts", "../../viem/src/actions/wallet/deployContract.ts", "../../viem/src/actions/wallet/getAddresses.ts", "../../viem/src/actions/wallet/getPermissions.ts", "../../viem/src/actions/wallet/requestAddresses.ts", "../../viem/src/actions/wallet/requestPermissions.ts", "../../viem/src/actions/wallet/signMessage.ts", "../../viem/src/actions/wallet/signTypedData.ts", "../../viem/src/actions/wallet/switchChain.ts", "../../viem/src/actions/wallet/watchAsset.ts", "../../viem/src/clients/decorators/wallet.ts", "../../viem/src/clients/createWalletClient.ts", "../../viem/src/clients/transports/webSocket.ts", "../../viem/src/constants/number.ts", "../../@wagmi/connectors/dist/chunk-QRUHVNWK.js"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// src/base.ts\nimport { default as EventEmitter } from \"eventemitter3\";\nimport { goerli, mainnet } from \"viem/chains\";\nvar Connector = class extends EventEmitter {\n  constructor({\n    chains = [mainnet, goerli],\n    options\n  }) {\n    super();\n    __publicField(this, \"chains\");\n    __publicField(this, \"options\");\n    __publicField(this, \"storage\");\n    this.chains = chains;\n    this.options = options;\n  }\n  getBlockExplorerUrls(chain) {\n    const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};\n    if (blockExplorer)\n      return [\n        blockExplorer.url,\n        ...Object.values(blockExplorers).map((x) => x.url)\n      ];\n  }\n  isChainUnsupported(chainId) {\n    return !this.chains.some((x) => x.id === chainId);\n  }\n  setStorage(storage) {\n    this.storage = storage;\n  }\n};\n\nexport {\n  __publicField,\n  __privateGet,\n  __privateAdd,\n  __privateSet,\n  __privateMethod,\n  Connector\n};\n", "import {\n  __publicField\n} from \"./chunk-QYMCVNHT.js\";\n\n// src/errors.ts\nvar ChainNotConfiguredForConnectorError = class extends Error {\n  constructor({\n    chainId,\n    connectorId\n  }) {\n    super(`Chain \"${chainId}\" not configured for connector \"${connectorId}\".`);\n    __publicField(this, \"name\", \"ChainNotConfiguredForConnectorError\");\n  }\n};\nvar ConnectorNotFoundError = class extends Error {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"name\", \"ConnectorNotFoundError\");\n    __publicField(this, \"message\", \"Connector not found\");\n  }\n};\n\nexport {\n  ChainNotConfiguredForConnectorError,\n  ConnectorNotFoundError\n};\n", "// src/utils/normalizeChainId.ts\nfunction normalizeChainId(chainId) {\n  if (typeof chainId === \"string\")\n    return Number.parseInt(\n      chainId,\n      chainId.trim().substring(0, 2) === \"0x\" ? 16 : 10\n    );\n  if (typeof chainId === \"bigint\")\n    return Number(chainId);\n  return chainId;\n}\n\nexport {\n  normalizeChainId\n};\n", "import { BaseError } from './base.js'\n\nexport class FilterTypeNotSupportedError extends BaseError {\n  override name = 'FilterTypeNotSupportedError'\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`)\n  }\n}\n", "import type { EventDefinition } from '../../types/contract.js'\nimport type { AbiEvent } from 'abitype'\n\nimport { hashAbiItem, hashFunction } from './hashFunction.js'\n\nexport const getEventSelector = (event: EventDefinition | AbiEvent) => {\n  if (typeof event === 'string') return hashFunction(event)\n  return hashAbiItem(event)\n}\n", "import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  Narrow,\n} from 'abitype'\n\nimport { AbiEventNotFoundError } from '../../errors/abi.js'\nimport { FilterTypeNotSupportedError } from '../../errors/log.js'\nimport type {\n  AbiItem,\n  EventDefinition,\n  GetEventArgs,\n  InferEventName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { getEventSelector } from '../hash/getEventSelector.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\nimport { encodeAbiParameters } from './encodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nexport type EncodeEventTopicsParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  _EventName = InferEventName<TAbi, TEventName>,\n> = {\n  eventName?: _EventName\n} & (TEventName extends string\n  ? { abi: Narrow<TAbi>; args?: GetEventArgs<TAbi, TEventName> }\n  : _EventName extends string\n  ? { abi: [Narrow<TAbi[number]>]; args?: GetEventArgs<TAbi, _EventName> }\n  : never)\n\nexport function encodeEventTopics<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined = undefined,\n>({ abi, eventName, args }: EncodeEventTopicsParameters<TAbi, TEventName>) {\n  let abiItem = abi[0] as AbiItem\n  if (eventName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: eventName,\n    } as GetAbiItemParameters)\n    if (!abiItem)\n      throw new AbiEventNotFoundError(eventName, {\n        docsPath: '/docs/contract/encodeEventTopics',\n      })\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, {\n      docsPath: '/docs/contract/encodeEventTopics',\n    })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = getEventSelector(definition as EventDefinition)\n\n  let topics: Hex[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n      ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n      : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) =>\n          Array.isArray(args_[i])\n            ? args_[i].map((_: any, j: number) =>\n                encodeArg({ param, value: args_[i][j] }),\n              )\n            : args_[i]\n            ? encodeArg({ param, value: args_[i] })\n            : null,\n        ) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { OnResponseFn } from '../../clients/transports/fallback.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { PublicRpcSchema } from '../../types/eip1193.js'\nimport type { EIP1193RequestFn } from '../../types/eip1193.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Filter } from '../../types/utils.js'\n\ntype CreateFilterRequestScopeParameters = {\n  method:\n    | 'eth_newFilter'\n    | 'eth_newPendingTransactionFilter'\n    | 'eth_newBlockFilter'\n}\n\ntype FilterRpcSchema = Filter<\n  PublicRpcSchema,\n  { Method: 'eth_getFilterLogs' | 'eth_getFilterChanges' }\n>\n\ntype CreateFilterRequestScopeReturnType = (\n  id: Hex,\n) => EIP1193RequestFn<FilterRpcSchema>\n\n/**\n * Scopes `request` to the filter ID. If the client is a fallback, it will\n * listen for responses and scope the child transport `request` function\n * to the successful filter ID.\n */\nexport function createFilterRequestScope<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { method }: CreateFilterRequestScopeParameters,\n): CreateFilterRequestScopeReturnType {\n  const requestMap: Record<Hex, EIP1193RequestFn> = {}\n\n  if (client.transport.type === 'fallback')\n    client.transport.onResponse?.(\n      ({\n        method: method_,\n        response: id,\n        status,\n        transport,\n      }: Parameters<OnResponseFn>[0]) => {\n        if (status === 'success' && method === method_)\n          requestMap[id as Hex] = transport.request\n      },\n    )\n\n  return ((id) =>\n    requestMap[id] || client.request) as CreateFilterRequestScopeReturnType\n}\n", "import type { Abi, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  InferEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateContractEventFilterParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = undefined,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  address?: Address | Address[]\n  abi: Narrow<TAbi>\n  eventName?: InferEventName<TAbi, TEventName>\n  fromBlock?: TFromBlock | BlockNumber | BlockTag\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments in the event ABI item.\n   * @default false\n   */\n  strict?: TStrict\n  toBlock?: TToBlock | BlockNumber | BlockTag\n} & (undefined extends TEventName\n  ? {\n      args?: never\n    }\n  : MaybeExtractEventArgsFromAbi<\n      TAbi,\n      TEventName\n    > extends infer TEventFilterArgs\n  ? {\n      args?: TEventFilterArgs | (TArgs extends TEventFilterArgs ? TArgs : never)\n    }\n  : {\n      args?: never\n    })\n\nexport type CreateContractEventFilterReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = undefined,\n  TArgs extends\n    | MaybeExtractEventArgsFromAbi<TAbi, TEventName>\n    | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = Filter<'event', TAbi, TEventName, TArgs, TStrict, TFromBlock, TToBlock>\n\n/**\n * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html).\n *\n * - Docs: https://viem.sh/docs/contract/createContractEventFilter.html\n *\n * @param client - Client to use\n * @param parameters - {@link CreateContractEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateContractEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n * })\n */\nexport async function createContractEventFilter<\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined,\n  TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    abi,\n    args,\n    eventName,\n    fromBlock,\n    strict,\n    toBlock,\n  }: CreateContractEventFilterParameters<\n    TAbi,\n    TEventName,\n    TArgs,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >,\n): Promise<\n  CreateContractEventFilterReturnType<\n    TAbi,\n    TEventName,\n    TArgs,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n> {\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  const topics = eventName\n    ? encodeEventTopics({\n        abi,\n        args,\n        eventName,\n      } as unknown as EncodeEventTopicsParameters)\n    : undefined\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        topics,\n      },\n    ],\n  })\n\n  return {\n    abi,\n    args,\n    eventName,\n    id,\n    request: getRequest(id),\n    strict,\n    type: 'event',\n  } as unknown as CreateContractEventFilterReturnType<\n    TAbi,\n    TEventName,\n    TArgs,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ContractFunctionExecutionError,\n  ContractFunctionRevertedError,\n  ContractFunctionZeroDataError,\n  RawContractError,\n} from '../../errors/contract.js'\n\nconst EXECUTION_REVERTED_ERROR_CODE = 3\n\nexport function getContractError(\n  err: BaseError,\n  {\n    abi,\n    address,\n    args,\n    docsPath,\n    functionName,\n    sender,\n  }: {\n    abi: Abi\n    args: any\n    address?: Address\n    docsPath?: string\n    functionName: string\n    sender?: Address\n  },\n) {\n  const { code, data, message, shortMessage } = (\n    err instanceof RawContractError\n      ? err\n      : err instanceof BaseError\n      ? err.walk((err) => 'data' in (err as Error)) || err.walk()\n      : {}\n  ) as RawContractError\n\n  let cause = err\n  if (err instanceof AbiDecodingZeroDataError) {\n    cause = new ContractFunctionZeroDataError({ functionName })\n  } else if (\n    code === EXECUTION_REVERTED_ERROR_CODE &&\n    (data || message || shortMessage)\n  ) {\n    cause = new ContractFunctionRevertedError({\n      abi,\n      data: typeof data === 'object' ? data.data : data,\n      functionName,\n      message: shortMessage ?? message,\n    })\n  }\n\n  return new ContractFunctionExecutionError(cause, {\n    abi,\n    args,\n    contractAddress: address,\n    docsPath,\n    functionName,\n    sender,\n  })\n}\n", "import { BaseError } from './base.js'\n\nexport class AccountNotFoundError extends BaseError {\n  override name = 'AccountNotFoundError'\n  constructor({ docsPath }: { docsPath?: string } = {}) {\n    super(\n      [\n        'Could not find an Account to execute with this Action.',\n        'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.',\n      ].join('\\n'),\n      {\n        docsPath,\n        docsSlug: 'account',\n      },\n    )\n  }\n}\n", "import type { Account } from '../accounts/types.js'\nimport type { EstimateGasParameters } from '../actions/public/estimateGas.js'\nimport type { Chain } from '../types/chain.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\nimport { prettyPrint } from './transaction.js'\n\nexport class EstimateGasExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'EstimateGasExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<EstimateGasParameters<any, any>, 'account'> & {\n      account?: Account\n      chain?: Chain\n      docsPath?: string\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Estimate Gas Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { EstimateGasParameters } from '../../actions/public/estimateGas.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { EstimateGasExecutionError } from '../../errors/estimateGas.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  containsNodeError,\n  getNodeError,\n} from './getNodeError.js'\n\nexport function getEstimateGasError(\n  err: BaseError,\n  {\n    docsPath,\n    ...args\n  }: Omit<EstimateGasParameters, 'account'> & {\n    account?: Account\n    chain?: Chain\n    docsPath?: string\n  },\n) {\n  let cause = err\n  if (containsNodeError(err))\n    cause = getNodeError(err, args as GetNodeErrorParameters)\n  return new EstimateGasExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n", "import type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport class BlockNotFoundError extends BaseError {\n  override name = 'BlockNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n  }: {\n    blockHash?: Hash\n    blockNumber?: bigint\n  }) {\n    let identifier = 'Block'\n    if (blockHash) identifier = `Block at hash \"${blockHash}\"`\n    if (blockNumber) identifier = `Block at number \"${blockNumber}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcBlock } from '../../types/rpc.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport {\n  type FormattedBlock,\n  formatBlock,\n} from '../../utils/formatters/block.js'\n\nexport type GetBlockParameters<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions\n} & (\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash\n      blockNumber?: never\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      /** The block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      /**\n       * The block tag.\n       * @default 'latest'\n       */\n      blockTag?: TBlockTag | BlockTag\n    }\n)\n\nexport type GetBlockReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = FormattedBlock<TChain, TIncludeTransactions, TBlockTag>\n\n/**\n * Returns information about a block at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlock.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockParameters}\n * @returns Information about the block. {@link GetBlockReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlock } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const block = await getBlock(client)\n */\nexport async function getBlock<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n>(\n  client: Client<Transport, TChain, TAccount>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag: blockTag_,\n    includeTransactions: includeTransactions_,\n  }: GetBlockParameters<TIncludeTransactions, TBlockTag> = {},\n): Promise<GetBlockReturnType<TChain, TIncludeTransactions, TBlockTag>> {\n  const blockTag = blockTag_ ?? 'latest'\n  const includeTransactions = includeTransactions_ ?? false\n\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let block: RpcBlock | null = null\n  if (blockHash) {\n    block = await client.request({\n      method: 'eth_getBlockByHash',\n      params: [blockHash, includeTransactions],\n    })\n  } else {\n    block = await client.request({\n      method: 'eth_getBlockByNumber',\n      params: [blockNumberHex || blockTag, includeTransactions],\n    })\n  }\n\n  if (!block) throw new BlockNotFoundError({ blockHash, blockNumber })\n\n  const format = client.chain?.formatters?.block?.format || formatBlock\n  return format(block)\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\n\nexport type GetGasPriceReturnType = bigint\n\n/**\n * Returns the current price of gas (in wei).\n *\n * - Docs: https://viem.sh/docs/actions/public/getGasPrice.html\n * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\n *\n * @param client - Client to use\n * @returns The gas price (in wei). {@link GetGasPriceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getGasPrice } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasPrice = await getGasPrice(client)\n */\nexport async function getGasPrice<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(client: Client<Transport, TChain, TAccount>): Promise<GetGasPriceReturnType> {\n  const gasPrice = await client.request({\n    method: 'eth_gasPrice',\n  })\n  return BigInt(gasPrice)\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport { hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetTransactionCountParameters = {\n  /** The account address. */\n  address: Address\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockNumber?: never\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag\n    }\n)\nexport type GetTransactionCountReturnType = number\n\n/**\n * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html\n * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionCountParameters}\n * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionCount = await getTransactionCount(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function getTransactionCount<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  { address, blockTag = 'latest', blockNumber }: GetTransactionCountParameters,\n): Promise<GetTransactionCountReturnType> {\n  const count = await client.request({\n    method: 'eth_getTransactionCount',\n    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag],\n  })\n  return hexToNumber(count)\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport {\n  type EstimateGasParameters,\n  estimateGas,\n} from '../../actions/public/estimateGas.js'\nimport { getBlock } from '../../actions/public/getBlock.js'\nimport { getGasPrice } from '../../actions/public/getGasPrice.js'\nimport { getTransactionCount } from '../../actions/public/getTransactionCount.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport { type AssertRequestParameters, assertRequest } from './assertRequest.js'\n\nexport type PrepareRequestParameters<\n  TAccount extends Account | undefined = undefined,\n> = GetAccountParameter<TAccount> & {\n  gas?: SendTransactionParameters['gas']\n  gasPrice?: SendTransactionParameters['gasPrice']\n  maxFeePerGas?: SendTransactionParameters['maxFeePerGas']\n  maxPriorityFeePerGas?: SendTransactionParameters['maxPriorityFeePerGas']\n  nonce?: SendTransactionParameters['nonce']\n}\n\nexport type PrepareRequestReturnType<\n  TAccount extends Account | undefined = undefined,\n  TParameters extends PrepareRequestParameters<TAccount> = PrepareRequestParameters<TAccount>,\n> = TParameters & {\n  from: Address\n  gas: SendTransactionParameters['gas']\n  gasPrice?: SendTransactionParameters['gasPrice']\n  maxFeePerGas?: SendTransactionParameters['maxFeePerGas']\n  maxPriorityFeePerGas?: SendTransactionParameters['maxPriorityFeePerGas']\n  nonce: SendTransactionParameters['nonce']\n}\n\nexport const defaultTip = 1_500_000_000n // 1.5 gwei\n\nexport async function prepareRequest<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TParameters extends PrepareRequestParameters<TAccount>,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: TParameters,\n): Promise<PrepareRequestReturnType<TAccount, TParameters>> {\n  const {\n    account: account_,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n  } = args\n  if (!account_) throw new AccountNotFoundError()\n  const account = parseAccount(account_)\n\n  const block = await getBlock(client, { blockTag: 'latest' })\n\n  const request = { ...args, from: account.address }\n\n  if (typeof nonce === 'undefined')\n    request.nonce = await getTransactionCount(client, {\n      address: account.address,\n      blockTag: 'pending',\n    })\n\n  if (typeof block.baseFeePerGas === 'bigint') {\n    if (typeof gasPrice !== 'undefined')\n      throw new BaseError('Chain does not support legacy `gasPrice`.')\n\n    // EIP-1559 fees\n    if (typeof maxFeePerGas === 'undefined') {\n      // Set a buffer of 1.2x on top of the base fee to account for fluctuations.\n      request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip\n      request.maxFeePerGas =\n        (block.baseFeePerGas * 120n) / 100n + request.maxPriorityFeePerGas\n    } else {\n      if (\n        typeof maxPriorityFeePerGas === 'undefined' &&\n        maxFeePerGas < defaultTip\n      )\n        throw new BaseError(\n          '`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).',\n        )\n      request.maxFeePerGas = maxFeePerGas\n      request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip\n    }\n  } else {\n    if (\n      typeof maxFeePerGas !== 'undefined' ||\n      typeof maxPriorityFeePerGas !== 'undefined'\n    )\n      throw new BaseError('Chain does not support EIP-1559 fees.')\n\n    // Legacy fees\n    if (typeof gasPrice === 'undefined')\n      // Set a buffer of 1.2x on top of the base fee to account for fluctuations.\n      request.gasPrice = ((await getGasPrice(client)) * 120n) / 100n\n  }\n\n  if (typeof gas === 'undefined')\n    request.gas = await estimateGas(client, {\n      ...request,\n      account: { address: account.address, type: 'json-rpc' },\n    } as EstimateGasParameters)\n\n  assertRequest(request as AssertRequestParameters)\n\n  return request as PrepareRequestReturnType<TAccount, TParameters>\n}\n", "import type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { getEstimateGasError } from '../../utils/errors/getEstimateGasError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { prepareRequest } from '../../utils/transaction/prepareRequest.js'\n\nexport type FormattedEstimateGas<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionRequest<TChain>\n\nexport type EstimateGasParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n> = UnionOmit<FormattedEstimateGas<TChain>, 'from'> &\n  GetAccountParameter<TAccount> &\n  (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint\n        blockTag?: never\n      }\n    | {\n        blockNumber?: never\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag\n      }\n  )\n\nexport type EstimateGasReturnType = bigint\n\n/**\n * Estimates the gas necessary to complete a transaction without submitting it to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/estimateGas.html\n * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseEther } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateGas } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gasEstimate = await estimateGas(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: parseEther('1'),\n * })\n */\nexport async function estimateGas<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: EstimateGasParameters<TChain, TAccount>,\n): Promise<EstimateGasReturnType> {\n  const account_ = args.account ?? client.account\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/public/estimateGas',\n    })\n  const account = parseAccount(account_)\n\n  try {\n    const {\n      accessList,\n      blockNumber,\n      blockTag,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n      ...rest\n    } = account.type === 'local' ? await prepareRequest(client, args) : args\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    assertRequest(args as AssertRequestParameters)\n\n    const format =\n      client.chain?.formatters?.transactionRequest?.format ||\n      formatTransactionRequest\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format }),\n      from: account.address,\n      accessList,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest)\n\n    const balance = await client.request({\n      method: 'eth_estimateGas',\n      params: block ? [request, block] : [request],\n    })\n    return BigInt(balance)\n  } catch (err) {\n    throw getEstimateGasError(err as BaseError, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionConfig, GetValue } from '../../types/contract.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\nimport { type EstimateGasParameters, estimateGas } from './estimateGas.js'\n\nexport type EstimateContractGasParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n> = ContractFunctionConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> &\n  UnionOmit<EstimateGasParameters<TChain, TAccount>, 'data' | 'to' | 'value'> &\n  GetValue<\n    TAbi,\n    TFunctionName,\n    EstimateGasParameters<TChain> extends EstimateGasParameters\n      ? EstimateGasParameters<TChain>['value']\n      : EstimateGasParameters['value']\n  >\n\nexport type EstimateContractGasReturnType = bigint\n\n/**\n * Estimates the gas required to successfully execute a contract write function call.\n *\n * - Docs: https://viem.sh/docs/contract/estimateContractGas.html\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * @param client - Client to use\n * @param parameters - {@link EstimateContractGasParameters}\n * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { estimateContractGas } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const gas = await estimateContractGas(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint() public']),\n *   functionName: 'mint',\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n * })\n */\nexport async function estimateContractGas<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...request\n  }: EstimateContractGasParameters<TAbi, TFunctionName, TChain, TAccount>,\n): Promise<EstimateContractGasReturnType> {\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const gas = await estimateGas(client, {\n      data,\n      to: address,\n      ...request,\n    } as unknown as EstimateGasParameters<TChain>)\n    return gas\n  } catch (err) {\n    const account = request.account ? parseAccount(request.account) : undefined\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionConfig,\n  ContractFunctionResult,\n} from '../../types/contract.js'\nimport {\n  type DecodeFunctionResultParameters,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\n\nimport { type CallParameters, call } from './call.js'\n\nexport type ReadContractParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = Pick<CallParameters, 'account' | 'blockNumber' | 'blockTag'> &\n  ContractFunctionConfig<TAbi, TFunctionName, 'view' | 'pure'>\n\nexport type ReadContractReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n> = ContractFunctionResult<TAbi, TFunctionName>\n\n/**\n * Calls a read-only function on a contract, and returns the response.\n *\n * - Docs: https://viem.sh/docs/contract/readContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/reading-contracts\n *\n * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * @param client - Client to use\n * @param parameters - {@link ReadContractParameters}\n * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { readContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await readContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n *   functionName: 'balanceOf',\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // 424122n\n */\nexport async function readContract<\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n>(\n  client: Client<Transport, TChain>,\n  {\n    abi,\n    address,\n    args,\n    functionName,\n    ...callRequest\n  }: ReadContractParameters<TAbi, TFunctionName>,\n): Promise<ReadContractReturnType<TAbi, TFunctionName>> {\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const { data } = await call(client, {\n      data: calldata,\n      to: address,\n      ...callRequest,\n    } as unknown as CallParameters)\n    return decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    } as DecodeFunctionResultParameters<\n      TAbi,\n      TFunctionName\n    >) as ReadContractReturnType<TAbi, TFunctionName>\n  } catch (err) {\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/readContract',\n      functionName,\n    })\n  }\n}\n", "import type { Abi } from 'abitype'\n\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionConfig,\n  ContractFunctionResult,\n  GetValue,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultParameters,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\nimport type { WriteContractParameters } from '../wallet/writeContract.js'\n\nimport { type CallParameters, call } from './call.js'\n\nexport type SimulateContractParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = any,\n  TChain extends Chain | undefined = Chain | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n> = {\n  chain?: TChainOverride\n  /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n  dataSuffix?: Hex\n} & ContractFunctionConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> &\n  UnionOmit<\n    CallParameters<TChainOverride extends Chain ? TChainOverride : TChain>,\n    'batch' | 'to' | 'data' | 'value'\n  > &\n  GetValue<\n    TAbi,\n    TFunctionName,\n    CallParameters<TChain> extends CallParameters\n      ? CallParameters<TChain>['value']\n      : CallParameters['value']\n  >\n\nexport type SimulateContractReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n  TChain extends Chain | undefined = Chain | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n> = {\n  result: ContractFunctionResult<TAbi, TFunctionName>\n  request: UnionOmit<\n    WriteContractParameters<\n      TAbi,\n      TFunctionName,\n      TChain,\n      undefined,\n      TChainOverride\n    >,\n    'chain' | 'functionName'\n  > & {\n    chain: TChainOverride\n    functionName: TFunctionName\n  } & ContractFunctionConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'>\n}\n\n/**\n * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n *\n * - Docs: https://viem.sh/docs/contract/simulateContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n *\n * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions.\n *\n * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * @param client - Client to use\n * @param parameters - {@link SimulateContractParameters}\n * @returns The simulation result and write request. {@link SimulateContractReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const result = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n *   functionName: 'mint',\n *   args: ['69420'],\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n */\nexport async function simulateContract<\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TChainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    abi,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...callRequest\n  }: SimulateContractParameters<TAbi, TFunctionName, TChain, TChainOverride>,\n): Promise<\n  SimulateContractReturnType<TAbi, TFunctionName, TChain, TChainOverride>\n> {\n  const account = callRequest.account\n    ? parseAccount(callRequest.account)\n    : undefined\n  const calldata = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  try {\n    const { data } = await call(client, {\n      batch: false,\n      data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n      to: address,\n      ...callRequest,\n    } as unknown as CallParameters<TChain>)\n    const result = decodeFunctionResult({\n      abi,\n      args,\n      functionName,\n      data: data || '0x',\n    } as DecodeFunctionResultParameters)\n    return {\n      result,\n      request: {\n        abi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...callRequest,\n      },\n    } as unknown as SimulateContractReturnType<\n      TAbi,\n      TFunctionName,\n      TChain,\n      TChainOverride\n    >\n  } catch (err) {\n    throw getContractError(err as BaseError, {\n      abi: abi as Abi,\n      address,\n      args,\n      docsPath: '/docs/contract/simulateContract',\n      functionName,\n      sender: account?.address,\n    })\n  }\n}\n", "import type { MaybePromise } from '../types/utils.js'\n\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport const listenersCache = /*#__PURE__*/ new Map<\n  string,\n  { id: number; fns: Callbacks }[]\n>()\nexport const cleanupCache = /*#__PURE__*/ new Map<string, () => void>()\n\ntype EmitFunction<TCallbacks extends Callbacks> = (\n  emit: TCallbacks,\n) => MaybePromise<void | (() => void)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<TCallbacks extends Callbacks>(\n  observerId: string,\n  callbacks: TCallbacks,\n  fn: EmitFunction<TCallbacks>,\n) {\n  const callbackId = ++callbackCount\n\n  const getListeners = () => listenersCache.get(observerId) || []\n\n  const unsubscribe = () => {\n    const listeners = getListeners()\n    listenersCache.set(\n      observerId,\n      listeners.filter((cb: any) => cb.id !== callbackId),\n    )\n  }\n\n  const unwatch = () => {\n    const cleanup = cleanupCache.get(observerId)\n    if (getListeners().length === 1 && cleanup) cleanup()\n    unsubscribe()\n  }\n\n  const listeners = getListeners()\n  listenersCache.set(observerId, [\n    ...listeners,\n    { id: callbackId, fns: callbacks },\n  ])\n\n  if (listeners && listeners.length > 0) return unwatch\n\n  const emit: TCallbacks = {} as TCallbacks\n  for (const key in callbacks) {\n    emit[key] = ((\n      ...args: Parameters<NonNullable<TCallbacks[keyof TCallbacks]>>\n    ) => {\n      const listeners = getListeners()\n      if (listeners.length === 0) return\n      listeners.forEach((listener) => listener.fns[key]?.(...args))\n    }) as TCallbacks[Extract<keyof TCallbacks, string>]\n  }\n\n  const cleanup = fn(emit)\n  if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup)\n\n  return unwatch\n}\n", "export async function wait(time: number) {\n  return new Promise((res) => setTimeout(res, time))\n}\n", "import { wait } from './wait.js'\n\ntype PollOptions<TData> = {\n  // Whether or not to emit when the polling starts.\n  emitOnBegin?: boolean\n  // The initial wait time (in ms) before polling.\n  initialWaitTime?: (data: TData | void) => Promise<number>\n  // The interval (in ms).\n  interval: number\n}\n\n/**\n * @description Polls a function at a specified interval.\n */\nexport function poll<TData>(\n  fn: ({ unpoll }: { unpoll: () => void }) => Promise<TData | void>,\n  { emitOnBegin, initialWaitTime, interval }: PollOptions<TData>,\n) {\n  let active = true\n\n  const unwatch = () => (active = false)\n\n  const watch = async () => {\n    let data: TData | void\n    if (emitOnBegin) data = await fn({ unpoll: unwatch })\n\n    const initialWait = (await initialWaitTime?.(data)) ?? interval\n    await wait(initialWait)\n\n    const poll = async () => {\n      if (!active) return\n      await fn({ unpoll: unwatch })\n      await wait(interval)\n      poll()\n    }\n\n    poll()\n  }\n  watch()\n\n  return unwatch\n}\n", "export const promiseCache = /*#__PURE__*/ new Map()\nexport const responseCache = /*#__PURE__*/ new Map()\n\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: (data: TData) => cache.set(cacheKey, data),\n  })\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache)\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  )\n\n  return {\n    clear: () => {\n      promise.clear()\n      response.clear()\n    },\n    promise,\n    response,\n  }\n}\n\nexport type WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number\n}\n\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Infinity }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey)\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get()\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime()\n    if (age < cacheTime) return response.data\n  }\n\n  let promise = cache.promise.get()\n  if (!promise) {\n    promise = fn()\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise)\n  }\n\n  try {\n    const data = await promise\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data })\n\n    return data\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear()\n  }\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getCache, withCache } from '../../utils/promise/withCache.js'\n\nexport type GetBlockNumberParameters = {\n  /** Time (in ms) that cached block number will remain in memory. */\n  cacheTime?: number\n  /** @deprecated use `cacheTime` instead. */\n  maxAge?: number\n}\n\nexport type GetBlockNumberReturnType = bigint\n\nconst cacheKey = (id: string) => `blockNumber.${id}`\n\nexport function getBlockNumberCache(id: string) {\n  return getCache(cacheKey(id))\n}\n\n/**\n * Returns the number of the most recent block seen.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks\n * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockNumberParameters}\n * @returns The number of the block. {@link GetBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockNumber } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const blockNumber = await getBlockNumber(client)\n * // 69420n\n */\nexport async function getBlockNumber<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { cacheTime = client.cacheTime, maxAge }: GetBlockNumberParameters = {},\n): Promise<GetBlockNumberReturnType> {\n  const blockNumberHex = await withCache(\n    () =>\n      client.request({\n        method: 'eth_blockNumber',\n      }),\n    { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime },\n  )\n  return BigInt(blockNumberHex)\n}\n", "import type { Abi, AbiParameter, ExtractAbiEventNames, Narrow } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  AbiEventSignatureEmptyTopicsError,\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type {\n  EventDefinition,\n  GetEventArgsFromTopics,\n  InferEventName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getEventSelector } from '../hash/getEventSelector.js'\n\nimport { decodeAbiParameters } from './decodeAbiParameters.js'\nimport { formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n> = {\n  abi: Narrow<TAbi>\n  data?: TData\n  eventName?: InferEventName<TAbi, TEventName>\n  strict?: TStrict\n  topics: [signature: Hex, ...args: TTopics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n  _EventNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiEventNames<TAbi>\n    : string,\n> = TEventName extends _EventNames[number]\n  ? Prettify<\n      {\n        eventName: TEventName\n      } & GetEventArgsFromTopics<TAbi, TEventName, TTopics, TData, TStrict>\n    >\n  : {\n      [TName in _EventNames]: Prettify<\n        {\n          eventName: TName\n        } & GetEventArgsFromTopics<TAbi, TName, TTopics, TData, TStrict>\n      >\n    }[_EventNames]\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined = undefined,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n>({\n  abi,\n  data,\n  strict: strict_,\n  topics,\n}: DecodeEventLogParameters<\n  TAbi,\n  TEventName,\n  TTopics,\n  TData,\n  TStrict\n>): DecodeEventLogReturnType<TAbi, TEventName, TTopics, TData, TStrict> {\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature)\n    throw new AbiEventSignatureEmptyTopicsError({\n      docsPath,\n    })\n  const abiItem = (abi as Abi).find(\n    (x) =>\n      x.type === 'event' &&\n      signature === getEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, {\n      docsPath,\n    })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  if (argTopics.length > 0) {\n    for (let i = 0; i < indexedInputs.length; i++) {\n      const param = indexedInputs[i]\n      const topic = argTopics[i]\n      if (!topic)\n        throw new DecodeLogTopicsMismatch({\n          abiItem,\n          param: param as AbiParameter & { indexed: boolean },\n        })\n      args[param.name || i] = decodeTopic({ param, value: topic })\n    }\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof AbiDecodingDataSizeTooSmallError)\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: err.data,\n              params: err.params,\n              size: err.size,\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<\n    TAbi,\n    TEventName,\n    TTopics,\n    TData,\n    TStrict\n  >\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n", "import type { Abi, AbiEvent, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter, FilterType } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash } from '../../types/misc.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport { formatLog } from '../../utils/formatters/log.js'\n\nexport type GetFilterChangesParameters<\n  TFilterType extends FilterType = FilterType,\n  TAbi extends Abi | readonly unknown[] | undefined = undefined,\n  TEventName extends string | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  filter: Filter<\n    TFilterType,\n    TAbi,\n    TEventName,\n    any,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n}\n\nexport type GetFilterChangesReturnType<\n  TFilterType extends FilterType = FilterType,\n  TAbi extends Abi | readonly unknown[] | undefined = undefined,\n  TEventName extends string | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _AbiEvent extends AbiEvent | undefined = TAbi extends Abi\n    ? TEventName extends string\n      ? ExtractAbiEvent<TAbi, TEventName>\n      : undefined\n    : undefined,\n  _Pending extends boolean =\n    | (TFromBlock extends 'pending' ? true : false)\n    | (TToBlock extends 'pending' ? true : false),\n> = TFilterType extends 'event'\n  ? Log<bigint, number, _Pending, _AbiEvent, TStrict, TAbi, TEventName>[]\n  : Hash[]\n\n/**\n * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html\n * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)\n *\n * A Filter can be created from the following actions:\n *\n * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)\n * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html)\n * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)\n * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)\n *\n * Depending on the type of filter, the return value will be different:\n *\n * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.\n * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.\n * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterChangesParameters}\n * @returns Logs or hashes. {@link GetFilterChangesReturnType}\n *\n * @example\n * // Blocks\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * const hashes = await getFilterChanges(client, { filter })\n *\n * @example\n * // Contract Events\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createContractEventFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createContractEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n *   eventName: 'Transfer',\n * })\n * const logs = await getFilterChanges(client, { filter })\n *\n * @example\n * // Raw Events\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterChanges(client, { filter })\n *\n * @example\n * // Transactions\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter, getFilterChanges } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createPendingTransactionFilter(client)\n * const hashes = await getFilterChanges(client, { filter })\n */\nexport async function getFilterChanges<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n  TFilterType extends FilterType,\n  TAbi extends Abi | readonly unknown[] | undefined,\n  TEventName extends string | undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  _client: Client<TTransport, TChain>,\n  {\n    filter,\n  }: GetFilterChangesParameters<\n    TFilterType,\n    TAbi,\n    TEventName,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >,\n): Promise<\n  GetFilterChangesReturnType<\n    TFilterType,\n    TAbi,\n    TEventName,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n> {\n  const strict = 'strict' in filter && filter.strict\n\n  const logs = await filter.request({\n    method: 'eth_getFilterChanges',\n    params: [filter.id],\n  })\n  return logs\n    .map((log) => {\n      if (typeof log === 'string') return log\n      try {\n        const { eventName, args } =\n          'abi' in filter && filter.abi\n            ? decodeEventLog({\n                abi: filter.abi,\n                data: log.data,\n                topics: log.topics as any,\n                strict,\n              })\n            : { eventName: undefined, args: undefined }\n        return formatLog(log, { args, eventName })\n      } catch (err) {\n        let eventName\n        let isUnnamed\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if ('strict' in filter && filter.strict) return\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args undefined if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return formatLog(log, { args: isUnnamed ? [] : {}, eventName })\n      }\n    })\n    .filter(Boolean) as GetFilterChangesReturnType<\n    TFilterType,\n    TAbi,\n    TEventName,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n}\n", "import type { Abi, AbiEvent, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hash, LogTopic } from '../../types/misc.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { formatLog } from '../../utils/formatters/log.js'\n\nexport type GetLogsParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  /** Address or list of addresses from which logs originated */\n  address?: Address | Address[]\n} & (\n  | {\n      event: Narrow<TAbiEvent>\n      events?: never\n      args?: MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: TStrict\n    }\n  | {\n      event?: never\n      events: Narrow<TAbiEvents>\n      args?: never\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: TStrict\n    }\n  | {\n      event?: never\n      events?: never\n      args?: never\n      strict?: never\n    }\n) &\n  (\n    | {\n        /** Block number or tag after which to include logs */\n        fromBlock?: TFromBlock | BlockNumber | BlockTag\n        /** Block number or tag before which to include logs */\n        toBlock?: TToBlock | BlockNumber | BlockTag\n        blockHash?: never\n      }\n    | {\n        fromBlock?: never\n        toBlock?: never\n        /** Hash of block to include logs from */\n        blockHash?: Hash\n      }\n  )\n\nexport type GetLogsReturnType<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  _Pending extends boolean =\n    | (TFromBlock extends 'pending' ? true : false)\n    | (TToBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _Pending, TAbiEvent, TStrict, TAbiEvents, _EventName>[]\n\n/**\n * Returns a list of event logs matching the provided parameters.\n *\n * - Docs: https://viem.sh/docs/actions/public/getLogs.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/filters-and-logs/event-logs\n * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n *\n * @param client - Client to use\n * @param parameters - {@link GetLogsParameters}\n * @returns A list of event logs. {@link GetLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const logs = await getLogs(client)\n */\nexport async function getLogs<\n  TChain extends Chain | undefined,\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    blockHash,\n    fromBlock,\n    toBlock,\n    event,\n    events: events_,\n    args,\n    strict: strict_,\n  }: GetLogsParameters<\n    TAbiEvent,\n    TAbiEvents,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  > = {},\n): Promise<\n  GetLogsReturnType<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock>\n> {\n  const strict = strict_ ?? false\n  const events = events_ ?? (event ? [event] : undefined)\n\n  let topics: LogTopic[] = []\n  if (events) {\n    topics = [\n      (events as AbiEvent[]).flatMap((event) =>\n        encodeEventTopics({\n          abi: [event],\n          eventName: (event as AbiEvent).name,\n          args,\n        } as EncodeEventTopicsParameters),\n      ),\n    ]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  let logs: RpcLog[]\n  if (blockHash) {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [{ address, topics, blockHash }],\n    })\n  } else {\n    logs = await client.request({\n      method: 'eth_getLogs',\n      params: [\n        {\n          address,\n          topics,\n          fromBlock:\n            typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n          toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        },\n      ],\n    })\n  }\n\n  return logs\n    .map((log) => {\n      try {\n        const { eventName, args } = events\n          ? decodeEventLog({\n              abi: events as Abi,\n              data: log.data,\n              topics: log.topics as any,\n              strict,\n            })\n          : { eventName: undefined, args: undefined }\n        return formatLog(log, { args, eventName: eventName as string })\n      } catch (err) {\n        let eventName\n        let isUnnamed\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return formatLog(log, { args: isUnnamed ? [] : {}, eventName })\n      }\n    })\n    .filter(Boolean) as unknown as GetLogsReturnType<\n    TAbiEvent,\n    TAbiEvents,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\n\nexport type UninstallFilterParameters = {\n  filter: Filter<any>\n}\nexport type UninstallFilterReturnType = boolean\n\n/**\n * Destroys a [`Filter`](https://viem.sh/docs/glossary/types.html#filter).\n *\n * - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html\n * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)\n *\n * Destroys a Filter that was created from one of the following Actions:\n * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)\n * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)\n * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)\n *\n * @param client - Client to use\n * @param parameters - {@link UninstallFilterParameters}\n * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'\n *\n * const filter = await createPendingTransactionFilter(client)\n * const uninstalled = await uninstallFilter(client, { filter })\n * // true\n */\nexport async function uninstallFilter<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n>(\n  _client: Client<TTransport, TChain>,\n  { filter }: UninstallFilterParameters,\n): Promise<UninstallFilterReturnType> {\n  return filter.request({\n    method: 'eth_uninstallFilter',\n    params: [filter.id],\n  })\n}\n", "import type { Abi, AbiEvent, Address, ExtractAbiEvent, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetEventArgs, InferEventName } from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport {\n  type GetAbiItemParameters,\n  getAbiItem,\n} from '../../utils/abi/getAbiItem.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  type CreateContractEventFilterParameters,\n  createContractEventFilter,\n} from './createContractEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchContractEventOnLogsParameter<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = TAbi extends Abi\n  ? Log<bigint, number, false, ExtractAbiEvent<TAbi, TEventName>, TStrict>[]\n  : Log[]\nexport type WatchContractEventOnLogsFn<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = (logs: WatchContractEventOnLogsParameter<TAbi, TEventName, TStrict>) => void\n\nexport type WatchContractEventParameters<\n  TAbi extends Abi | readonly unknown[] = readonly unknown[],\n  TEventName extends string = string,\n  TStrict extends boolean | undefined = undefined,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /** Contract ABI. */\n  abi: Narrow<TAbi>\n  args?: GetEventArgs<TAbi, TEventName>\n  /** Whether or not the event logs should be batched on each invocation. */\n  batch?: boolean\n  /** Contract event. */\n  eventName?: InferEventName<TAbi, TEventName>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchContractEventOnLogsFn<TAbi, TEventName, TStrict>\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n  /**\n   * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n   * @default false\n   */\n  strict?: TStrict\n}\n\nexport type WatchContractEventReturnType = () => void\n\n/**\n * Watches and returns emitted contract event logs.\n *\n * - Docs: https://viem.sh/docs/contract/watchContractEvent.html\n *\n * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n *\n * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchContractEventParameters}\n * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchContractEvent } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchContractEvent(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n *   eventName: 'Transfer',\n *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchContractEvent<\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TStrict extends boolean | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    abi,\n    address,\n    args,\n    batch = true,\n    eventName,\n    onError,\n    onLogs,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchContractEventParameters<TAbi, TEventName, TStrict>,\n): WatchContractEventReturnType {\n  const observerId = stringify([\n    'watchContractEvent',\n    address,\n    args,\n    batch,\n    client.uid,\n    eventName,\n    pollingInterval,\n  ])\n  const strict = strict_ ?? false\n\n  return observe(observerId, { onLogs, onError }, (emit) => {\n    let previousBlockNumber: bigint\n    let filter: Filter<'event', TAbi, TEventName> | undefined\n    let initialized = false\n\n    const unwatch = poll(\n      async () => {\n        if (!initialized) {\n          try {\n            filter = (await createContractEventFilter(client, {\n              abi,\n              address,\n              args,\n              eventName,\n              strict,\n            } as unknown as CreateContractEventFilterParameters)) as Filter<\n              'event',\n              TAbi,\n              TEventName\n            >\n          } catch {}\n          initialized = true\n          return\n        }\n\n        try {\n          let logs: Log[]\n          if (filter) {\n            logs = await getFilterChanges(client, { filter })\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getBlockNumber(client)\n\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await getLogs(client, {\n                address,\n                args,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber,\n                event: getAbiItem({\n                  abi,\n                  name: eventName,\n                } as unknown as GetAbiItemParameters) as AbiEvent,\n              })\n            } else {\n              logs = []\n            }\n            previousBlockNumber = blockNumber\n          }\n\n          if (logs.length === 0) return\n          if (batch) emit.onLogs(logs as any)\n          else logs.forEach((log) => emit.onLogs([log] as any))\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin: true,\n        interval: pollingInterval,\n      },\n    )\n\n    return async () => {\n      if (filter) await uninstallFilter(client, { filter })\n      unwatch()\n    }\n  })\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { SendTransactionParameters } from '../../actions/wallet/sendTransaction.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { TransactionExecutionError } from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\n\nimport {\n  type GetNodeErrorParameters,\n  containsNodeError,\n  getNodeError,\n} from './getNodeError.js'\n\nexport type GetTransactionErrorParameters = Omit<\n  SendTransactionParameters,\n  'account' | 'chain'\n> & {\n  account: Account\n  chain?: Chain\n  docsPath?: string\n}\n\nexport function getTransactionError(\n  err: BaseError,\n  { docsPath, ...args }: GetTransactionErrorParameters,\n) {\n  let cause = err\n  if (containsNodeError(err))\n    cause = getNodeError(err, args as GetNodeErrorParameters)\n  return new TransactionExecutionError(cause, {\n    docsPath,\n    ...args,\n  })\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport { hexToNumber } from '../../utils/encoding/fromHex.js'\n\nexport type GetChainIdReturnType = number\n\n/**\n * Returns the chain ID associated with the current network.\n *\n * - Docs: https://viem.sh/docs/actions/public/getChainId.html\n * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n *\n * @param client - Client to use\n * @returns The current chain ID. {@link GetChainIdReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getChainId } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const chainId = await getChainId(client)\n * // 1\n */\nexport async function getChainId<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(client: Client<Transport, TChain, TAccount>): Promise<GetChainIdReturnType> {\n  const chainIdHex = await client.request({\n    method: 'eth_chainId',\n  })\n  return hexToNumber(chainIdHex)\n}\n", "import type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { BaseError } from '../../errors/base.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain, GetChain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type {\n  TransactionRequest,\n  TransactionSerializable,\n} from '../../types/transaction.js'\nimport type { IsUndefined, UnionOmit } from '../../types/utils.js'\nimport { assertCurrentChain } from '../../utils/chain.js'\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport { prepareRequest } from '../../utils/transaction/prepareRequest.js'\nimport { getChainId } from '../public/getChainId.js'\n\nexport type SendTransactionParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = Chain,\n> = UnionOmit<\n  FormattedTransactionRequest<\n    IsUndefined<TChain> extends true ? TChainOverride : TChain\n  >,\n  'from'\n> &\n  GetAccountParameter<TAccount> &\n  GetChain<TChain, TChainOverride>\n\nexport type SendTransactionReturnType = Hash\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: SendTransactionParameters<TChain, TAccount, TChainOverride>,\n): Promise<SendTransactionReturnType> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    ...rest\n  } = args\n\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransaction',\n    })\n  const account = parseAccount(account_)\n\n  try {\n    assertRequest(args)\n\n    let chainId\n    if (chain !== null) {\n      chainId = await getChainId(client)\n      assertCurrentChain({\n        currentChainId: chainId,\n        chain,\n      })\n    }\n\n    if (account.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await prepareRequest(client, {\n        account,\n        accessList,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        value,\n        ...rest,\n      })\n\n      if (!chainId) chainId = await getChainId(client)\n\n      const serializer = chain?.serializers?.transaction\n      const signedRequest = (await account.signTransaction(\n        {\n          ...request,\n          chainId,\n        } as TransactionSerializable,\n        { serializer },\n      )) as Hash\n      return await client.request({\n        method: 'eth_sendRawTransaction',\n        params: [signedRequest],\n      })\n    }\n\n    const format =\n      chain?.formatters?.transactionRequest?.format || formatTransactionRequest\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format }),\n      accessList,\n      data,\n      from: account.address,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest)\n    return await client.request({\n      method: 'eth_sendTransaction',\n      params: [request],\n    })\n  } catch (err) {\n    throw getTransactionError(err as BaseError, {\n      ...args,\n      account,\n      chain: args.chain || undefined,\n    })\n  }\n}\n", "import type { Abi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain, GetChain } from '../../types/chain.js'\nimport type { ContractFunctionConfig, GetValue } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\n\nimport {\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\n\nexport type WriteContractParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TFunctionName extends string = string,\n  TChain extends Chain | undefined = Chain,\n  TAccount extends Account | undefined = undefined,\n  TChainOverride extends Chain | undefined = undefined,\n> = ContractFunctionConfig<TAbi, TFunctionName, 'payable' | 'nonpayable'> &\n  UnionOmit<\n    SendTransactionParameters<TChain, TAccount, TChainOverride>,\n    'chain' | 'to' | 'data' | 'value'\n  > &\n  GetChain<TChain, TChainOverride> &\n  GetValue<\n    TAbi,\n    TFunctionName,\n    SendTransactionParameters<\n      TChain,\n      TAccount,\n      TChainOverride\n    > extends SendTransactionParameters\n      ? SendTransactionParameters<TChain, TAccount, TChainOverride>['value']\n      : SendTransactionParameters['value']\n  > & {\n    /** Data to append to the end of the calldata. Useful for adding a [\"domain\" tag](https://opensea.notion.site/opensea/Seaport-Order-Attributions-ec2d69bf455041a5baa490941aad307f). */\n    dataSuffix?: Hex\n  }\n\nexport type WriteContractReturnType = SendTransactionReturnType\n\n/**\n * Executes a write function on a contract.\n *\n * - Docs: https://viem.sh/docs/contract/writeContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash). {@link WriteContractReturnType}\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport async function writeContract<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TChainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  {\n    abi,\n    address,\n    args,\n    dataSuffix,\n    functionName,\n    ...request\n  }: WriteContractParameters<\n    TAbi,\n    TFunctionName,\n    TChain,\n    TAccount,\n    TChainOverride\n  >,\n): Promise<WriteContractReturnType> {\n  const data = encodeFunctionData({\n    abi,\n    args,\n    functionName,\n  } as unknown as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n  const hash = await sendTransaction(client, {\n    data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,\n    to: address,\n    ...request,\n  } as unknown as SendTransactionParameters<TChain, TAccount, TChainOverride>)\n  return hash\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type AddChainParameters = {\n  /** The chain to add to the wallet. */\n  chain: Chain\n}\n\n/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/addChain.html\n * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n *\n * @param client - Client to use\n * @param parameters - {@link AddChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { optimism } from 'viem/chains'\n * import { addChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   transport: custom(window.ethereum),\n * })\n * await addChain(client, { chain: optimism })\n */\nexport async function addChain<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(client: Client<Transport, TChain, TAccount>, { chain }: AddChainParameters) {\n  const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain\n  await client.request({\n    method: 'wallet_addEthereumChain',\n    params: [\n      {\n        chainId: numberToHex(id),\n        chainName: name,\n        nativeCurrency,\n        rpcUrls: rpcUrls.default.http,\n        blockExplorerUrls: blockExplorers\n          ? Object.values(blockExplorers).map(({ url }) => url)\n          : undefined,\n      },\n    ],\n  })\n}\n", "const size = 256\nlet index = size\nlet buffer: string\n\nexport function uid(length = 11) {\n  if (!buffer || index + length > size * 2) {\n    buffer = ''\n    index = 0\n    for (let i = 0; i < size; i++) {\n      buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1)\n    }\n  }\n  return buffer.substring(index, index++ + length)\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account, JsonRpcAccount } from '../accounts/types.js'\nimport type { Chain } from '../types/chain.js'\nimport type {\n  EIP1193RequestFn,\n  EIP1474Methods,\n  RpcSchema,\n} from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport { parseAccount } from '../utils/accounts.js'\nimport { uid } from '../utils/uid.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type ClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = {\n  /** The Account to use for the Client. This will be used for Actions that require an account as an argument. */\n  account?: accountOrAddress | Account | Address | undefined\n  /** Flags for batch settings. */\n  batch?:\n    | {\n        /** Toggle to enable `eth_call` multicall aggregation. */\n        multicall?: boolean | Prettify<MulticallBatchOptions> | undefined\n      }\n    | undefined\n  /**\n   * Time (in ms) that cached data will remain in memory.\n   * @default 4_000\n   */\n  cacheTime?: number | undefined\n  /** Chain for the client. */\n  chain?: Chain | undefined | chain\n  /** A key for the client. */\n  key?: string | undefined\n  /** A name for the client. */\n  name?: string | undefined\n  /**\n   * Frequency (in ms) for polling enabled actions & events.\n   * @default 4_000\n   */\n  pollingInterval?: number | undefined\n  /** The RPC transport */\n  transport: transport\n  /** The type of client. */\n  type?: string | undefined\n}\n\n// TODO: Move `transport` to slot index 2 since `chain` and `account` used more frequently.\n// Otherwise, we end up with a lot of `Client<Transport, chain, account>` in actions.\nexport type Client<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n  extended extends Extended | undefined = Extended | undefined,\n> = Client_Base<transport, chain, account, rpcSchema> &\n  (extended extends Extended ? extended : unknown) & {\n    extend: <const client extends Extended>(\n      fn: (\n        client: Client<transport, chain, account, rpcSchema, extended>,\n      ) => client,\n    ) => Client<\n      transport,\n      chain,\n      account,\n      rpcSchema,\n      Prettify<client> & (extended extends Extended ? extended : unknown)\n    >\n  }\n\ntype Client_Base<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  rpcSchema extends RpcSchema | undefined = undefined,\n> = {\n  /** The Account of the Client. */\n  account: account\n  /** Flags for batch settings. */\n  batch?: ClientConfig['batch']\n  /** Time (in ms) that cached data will remain in memory. */\n  cacheTime: number\n  /** Chain for the client. */\n  chain: chain\n  /** A key for the client. */\n  key: string\n  /** A name for the client. */\n  name: string\n  /** Frequency (in ms) for polling enabled actions & events. Defaults to 4_000 milliseconds. */\n  pollingInterval: number\n  /** Request function wrapped with friendly error handling */\n  request: EIP1193RequestFn<\n    rpcSchema extends undefined ? EIP1474Methods : rpcSchema\n  >\n  /** The RPC transport */\n  transport: ReturnType<transport>['config'] & ReturnType<transport>['value']\n  /** The type of client. */\n  type: string\n  /** A unique ID for the client. */\n  uid: string\n}\n\ntype Extended = Prettify<\n  // disallow redefining base properties\n  { [K in keyof Client_Base]?: undefined } & {\n    [key: string]: unknown\n  }\n>\n\nexport type MulticallBatchOptions = {\n  /** The maximum size (in bytes) for each calldata chunk. @default 1_024 */\n  batchSize?: number | undefined\n  /** The maximum number of milliseconds to wait before sending a batch. @default 0 */\n  wait?: number | undefined\n}\n\n/**\n * Creates a base client with the given transport.\n */\nexport function createClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n>(\n  parameters: ClientConfig<transport, chain, accountOrAddress>,\n): Prettify<\n  Client<\n    transport,\n    chain,\n    accountOrAddress extends Address\n      ? Prettify<JsonRpcAccount<accountOrAddress>>\n      : accountOrAddress\n  >\n>\n\nexport function createClient(parameters: ClientConfig): Client {\n  const {\n    batch,\n    cacheTime = parameters.pollingInterval ?? 4_000,\n    key = 'base',\n    name = 'Base Client',\n    pollingInterval = 4_000,\n    type = 'base',\n  } = parameters\n\n  const chain = parameters.chain\n  const account = parameters.account\n    ? parseAccount(parameters.account)\n    : undefined\n  const { config, request, value } = parameters.transport({\n    chain,\n    pollingInterval,\n  })\n  const transport = { ...config, ...value }\n\n  const client = {\n    account,\n    batch,\n    cacheTime,\n    chain,\n    key,\n    name,\n    pollingInterval,\n    request,\n    transport,\n    type,\n    uid: uid(),\n  }\n\n  function extend(base: typeof client) {\n    type ExtendFn = (base: typeof client) => unknown\n    return (extendFn: ExtendFn) => {\n      const extended = extendFn(base) as Extended\n      for (const key in client) delete extended[key]\n      const combined = { ...base, ...extended }\n      return Object.assign(combined, { extend: extend(combined) })\n    }\n  }\n\n  return Object.assign(client, { extend: extend(client) as any })\n}\n", "import { wait } from '../wait.js'\n\nexport function withRetry<TData>(\n  fn: () => Promise<TData>,\n  {\n    delay: delay_ = 100,\n    retryCount = 2,\n    shouldRetry = () => true,\n  }: {\n    // The delay (in ms) between retries.\n    delay?: ((config: { count: number; error: Error }) => number) | number\n    // The max number of times to retry.\n    retryCount?: number\n    // Whether or not to retry when an error is thrown.\n    shouldRetry?: ({\n      count,\n      error,\n    }: {\n      count: number\n      error: Error\n    }) => Promise<boolean> | boolean\n  } = {},\n) {\n  return new Promise<TData>((resolve, reject) => {\n    const attemptRetry = async ({ count = 0 } = {}) => {\n      const retry = async ({ error }: { error: Error }) => {\n        const delay =\n          typeof delay_ === 'function' ? delay_({ count, error }) : delay_\n        if (delay) await wait(delay)\n        attemptRetry({ count: count + 1 })\n      }\n\n      try {\n        const data = await fn()\n        resolve(data)\n      } catch (err) {\n        if (\n          count < retryCount &&\n          (await shouldRetry({ count, error: err as Error }))\n        )\n          return retry({ error: err as Error })\n        reject(err)\n      }\n    }\n    attemptRetry()\n  })\n}\n", "import { BaseError } from '../errors/base.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport {\n  ChainDisconnectedError,\n  InternalRpcError,\n  InvalidInputRpcError,\n  InvalidParamsRpcError,\n  InvalidRequestRpcError,\n  JsonRpcVersionUnsupportedError,\n  LimitExceededRpcError,\n  MethodNotFoundRpcError,\n  MethodNotSupportedRpcError,\n  ParseRpcError,\n  ProviderDisconnectedError,\n  type ProviderRpcErrorCode,\n  ResourceNotFoundRpcError,\n  ResourceUnavailableRpcError,\n  type RpcError,\n  type RpcErrorCode,\n  SwitchChainError,\n  TransactionRejectedRpcError,\n  UnauthorizedProviderError,\n  UnknownRpcError,\n  UnsupportedProviderMethodError,\n  UserRejectedRequestError,\n} from '../errors/rpc.js'\n\nimport { withRetry } from './promise/withRetry.js'\n\nexport const isDeterministicError = (error: Error) => {\n  if ('code' in error)\n    return (\n      error.code !== -1 &&\n      error.code !== -32004 &&\n      error.code !== -32005 &&\n      error.code !== -32042 &&\n      error.code !== -32603\n    )\n  if (error instanceof HttpRequestError && error.status)\n    return (\n      error.status !== 403 &&\n      error.status !== 408 &&\n      error.status !== 413 &&\n      error.status !== 429 &&\n      error.status !== 500 &&\n      error.status !== 502 &&\n      error.status !== 503 &&\n      error.status !== 504\n    )\n  return false\n}\n\nexport function buildRequest<TRequest extends (args: any) => Promise<any>>(\n  request: TRequest,\n  {\n    retryDelay = 150,\n    retryCount = 3,\n  }: {\n    // The base delay (in ms) between retries.\n    retryDelay?: number\n    // The max number of times to retry.\n    retryCount?: number\n  } = {},\n) {\n  return (async (args: any) =>\n    withRetry(\n      async () => {\n        try {\n          return await request(args)\n        } catch (err_) {\n          const err = err_ as unknown as RpcError<\n            RpcErrorCode | ProviderRpcErrorCode\n          >\n          switch (err.code) {\n            // -32700\n            case ParseRpcError.code:\n              throw new ParseRpcError(err)\n            // -32600\n            case InvalidRequestRpcError.code:\n              throw new InvalidRequestRpcError(err)\n            // -32601\n            case MethodNotFoundRpcError.code:\n              throw new MethodNotFoundRpcError(err)\n            // -32602\n            case InvalidParamsRpcError.code:\n              throw new InvalidParamsRpcError(err)\n            // -32603\n            case InternalRpcError.code:\n              throw new InternalRpcError(err)\n            // -32000\n            case InvalidInputRpcError.code:\n              throw new InvalidInputRpcError(err)\n            // -32001\n            case ResourceNotFoundRpcError.code:\n              throw new ResourceNotFoundRpcError(err)\n            // -32002\n            case ResourceUnavailableRpcError.code:\n              throw new ResourceUnavailableRpcError(err)\n            // -32003\n            case TransactionRejectedRpcError.code:\n              throw new TransactionRejectedRpcError(err)\n            // -32004\n            case MethodNotSupportedRpcError.code:\n              throw new MethodNotSupportedRpcError(err)\n            // -32005\n            case LimitExceededRpcError.code:\n              throw new LimitExceededRpcError(err)\n            // -32006\n            case JsonRpcVersionUnsupportedError.code:\n              throw new JsonRpcVersionUnsupportedError(err)\n            // 4001\n            case UserRejectedRequestError.code:\n              throw new UserRejectedRequestError(err)\n            // 4100\n            case UnauthorizedProviderError.code:\n              throw new UnauthorizedProviderError(err)\n            // 4200\n            case UnsupportedProviderMethodError.code:\n              throw new UnsupportedProviderMethodError(err)\n            // 4900\n            case ProviderDisconnectedError.code:\n              throw new ProviderDisconnectedError(err)\n            // 4901\n            case ChainDisconnectedError.code:\n              throw new ChainDisconnectedError(err)\n            // 4902\n            case SwitchChainError.code:\n              throw new SwitchChainError(err)\n            default:\n              if (err_ instanceof BaseError) throw err_\n              throw new UnknownRpcError(err as Error)\n          }\n        }\n      },\n      {\n        delay: ({ count, error }) => {\n          // If we find a Retry-After header, let's retry after the given time.\n          if (error && error instanceof HttpRequestError) {\n            const retryAfter = error?.headers?.get('Retry-After')\n            if (retryAfter?.match(/\\d/)) return parseInt(retryAfter) * 1000\n          }\n\n          // Otherwise, let's retry with an exponential backoff.\n          return ~~(1 << count) * retryDelay\n        },\n        retryCount,\n        shouldRetry: ({ error }) => !isDeterministicError(error),\n      },\n    )) as TRequest\n}\n", "import type { Chain } from '../../types/chain.js'\nimport type { EIP1193RequestFn } from '../../types/eip1193.js'\nimport { buildRequest } from '../../utils/buildRequest.js'\nimport type { ClientConfig } from '../createClient.js'\n\nexport type TransportConfig<\n  TType extends string = string,\n  TEIP1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,\n> = {\n  /** The name of the transport. */\n  name: string\n  /** The key of the transport. */\n  key: string\n  /** The JSON-RPC request function that matches the EIP-1193 request spec. */\n  request: TEIP1193RequestFn\n  /** The base delay (in ms) between retries. */\n  retryDelay?: number\n  /** The max number of times to retry. */\n  retryCount?: number\n  /** The timeout (in ms) for requests. */\n  timeout?: number\n  /** The type of the transport. */\n  type: TType\n}\n\nexport type Transport<\n  TType extends string = string,\n  TRpcAttributes = Record<string, any>,\n  TEIP1193RequestFn extends EIP1193RequestFn = EIP1193RequestFn,\n> = <TChain extends Chain | undefined = Chain>({\n  chain,\n}: {\n  chain?: TChain\n  pollingInterval?: ClientConfig['pollingInterval']\n  retryCount?: TransportConfig['retryCount']\n  timeout?: TransportConfig['timeout']\n}) => {\n  config: TransportConfig<TType>\n  request: TEIP1193RequestFn\n  value?: TRpcAttributes\n}\n\n/**\n * @description Creates an transport intended to be used with a client.\n */\nexport function createTransport<\n  TType extends string,\n  TRpcAttributes extends Record<string, any>,\n>(\n  {\n    key,\n    name,\n    request,\n    retryCount = 3,\n    retryDelay = 150,\n    timeout,\n    type,\n  }: TransportConfig<TType>,\n  value?: TRpcAttributes,\n): ReturnType<Transport<TType, TRpcAttributes>> {\n  return {\n    config: { key, name, request, retryCount, retryDelay, timeout, type },\n    request: buildRequest(request, { retryCount, retryDelay }),\n    value,\n  }\n}\n", "import {\n  type Transport,\n  type TransportConfig,\n  createTransport,\n} from './createTransport.js'\n\ntype EthereumProvider = { request(...args: any): Promise<any> }\n\nexport type CustomTransportConfig = {\n  /** The key of the transport. */\n  key?: TransportConfig['key']\n  /** The name of the transport. */\n  name?: TransportConfig['name']\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount']\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay']\n}\n\nexport type CustomTransport = Transport<\n  'custom',\n  {},\n  EthereumProvider['request']\n>\n\n/**\n * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.\n */\nexport function custom<TProvider extends EthereumProvider>(\n  provider: TProvider,\n  config: CustomTransportConfig = {},\n): CustomTransport {\n  const { key = 'custom', name = 'Custom Provider', retryDelay } = config\n  return ({ retryCount: defaultRetryCount }) =>\n    createTransport({\n      key,\n      name,\n      request: provider.request.bind(provider),\n      retryCount: config.retryCount ?? defaultRetryCount,\n      retryDelay,\n      type: 'custom',\n    })\n}\n", "import type { Chain } from '../../types/chain.js'\nimport { isDeterministicError } from '../../utils/buildRequest.js'\nimport { wait } from '../../utils/wait.js'\n\nimport {\n  type Transport,\n  type TransportConfig,\n  createTransport,\n} from './createTransport.js'\n// TODO: Narrow `method` & `params` types.\nexport type OnResponseFn = (\n  args: {\n    method: string\n    params: unknown[]\n    transport: ReturnType<Transport>\n  } & (\n    | {\n        error?: never\n        response: unknown\n        status: 'success'\n      }\n    | {\n        error: Error\n        response?: never\n        status: 'error'\n      }\n  ),\n) => void\n\ntype RankOptions = {\n  /**\n   * The polling interval (in ms) at which the ranker should ping the RPC URL.\n   * @default client.pollingInterval\n   */\n  interval?: number\n  /**\n   * The number of previous samples to perform ranking on.\n   * @default 10\n   */\n  sampleCount?: number\n  /**\n   * Timeout when sampling transports.\n   * @default 1_000\n   */\n  timeout?: number\n  /**\n   * Weights to apply to the scores. Weight values are proportional.\n   */\n  weights?: {\n    /**\n     * The weight to apply to the latency score.\n     * @default 0.3\n     */\n    latency?: number\n    /**\n     * The weight to apply to the stability score.\n     * @default 0.7\n     */\n    stability?: number\n  }\n}\n\nexport type FallbackTransportConfig = {\n  /** The key of the Fallback transport. */\n  key?: TransportConfig['key']\n  /** The name of the Fallback transport. */\n  name?: TransportConfig['name']\n  /** Toggle to enable ranking, or rank options. */\n  rank?: boolean | RankOptions\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount']\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay']\n}\n\nexport type FallbackTransport = Transport<\n  'fallback',\n  {\n    onResponse: (fn: OnResponseFn) => void\n    transports: ReturnType<Transport>[]\n  }\n>\n\nexport function fallback(\n  transports_: Transport[],\n  config: FallbackTransportConfig = {},\n): FallbackTransport {\n  const {\n    key = 'fallback',\n    name = 'Fallback',\n    rank = false,\n    retryCount,\n    retryDelay,\n  } = config\n  return ({ chain, pollingInterval = 4_000, timeout }) => {\n    let transports = transports_\n\n    let onResponse: OnResponseFn = () => {}\n\n    const transport = createTransport(\n      {\n        key,\n        name,\n        async request({ method, params }) {\n          const fetch = async (i = 0): Promise<any> => {\n            const transport = transports[i]({ chain, retryCount: 0, timeout })\n            try {\n              const response = await transport.request({\n                method,\n                params,\n              } as any)\n\n              onResponse({\n                method,\n                params: params as unknown[],\n                response,\n                transport,\n                status: 'success',\n              })\n\n              return response\n            } catch (err) {\n              onResponse({\n                error: err as Error,\n                method,\n                params: params as unknown[],\n                transport,\n                status: 'error',\n              })\n\n              // If the error is deterministic, we don't need to fall back.\n              // So throw the error.\n              if (isDeterministicError(err as Error)) throw err\n\n              // If we've reached the end of the fallbacks, throw the error.\n              if (i === transports.length - 1) throw err\n\n              // Otherwise, try the next fallback.\n              return fetch(i + 1)\n            }\n          }\n          return fetch()\n        },\n        retryCount,\n        retryDelay,\n        type: 'fallback',\n      },\n      {\n        onResponse: (fn: OnResponseFn) => (onResponse = fn),\n        transports: transports.map((fn) => fn({ chain, retryCount: 0 })),\n      },\n    )\n\n    if (rank) {\n      const rankOptions = (typeof rank === 'object' ? rank : {}) as RankOptions\n      rankTransports({\n        chain,\n        interval: rankOptions.interval ?? pollingInterval,\n        onTransports: (transports_) => (transports = transports_),\n        sampleCount: rankOptions.sampleCount,\n        timeout: rankOptions.timeout,\n        transports,\n        weights: rankOptions.weights,\n      })\n    }\n    return transport\n  }\n}\n\nexport function rankTransports({\n  chain,\n  interval = 4_000,\n  onTransports,\n  sampleCount = 10,\n  timeout = 1_000,\n  transports,\n  weights = {},\n}: {\n  chain?: Chain\n  interval: RankOptions['interval']\n  onTransports: (transports: Transport[]) => void\n  sampleCount?: RankOptions['sampleCount']\n  timeout?: RankOptions['timeout']\n  transports: Transport[]\n  weights?: RankOptions['weights']\n}) {\n  const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } =\n    weights\n\n  type SampleData = { latency: number; success: number }\n  type Sample = SampleData[]\n  const samples: Sample[] = []\n\n  const rankTransports_ = async () => {\n    // 1. Take a sample from each Transport.\n    const sample: Sample = await Promise.all(\n      transports.map(async (transport) => {\n        const transport_ = transport({ chain, retryCount: 0, timeout })\n\n        const start = Date.now()\n        let end\n        let success\n        try {\n          await transport_.request({ method: 'net_listening' })\n          success = 1\n        } catch {\n          success = 0\n        } finally {\n          end = Date.now()\n        }\n        const latency = end - start\n        return { latency, success }\n      }),\n    )\n\n    // 2. Store the sample. If we have more than `sampleCount` samples, remove\n    // the oldest sample.\n    samples.push(sample)\n    if (samples.length > sampleCount) samples.shift()\n\n    // 3. Calculate the max latency from samples.\n    const maxLatency = Math.max(\n      ...samples.map((sample) =>\n        Math.max(...sample.map(({ latency }) => latency)),\n      ),\n    )\n\n    // 4. Calculate the score for each Transport.\n    const scores = transports\n      .map((_, i) => {\n        const latencies = samples.map((sample) => sample[i].latency)\n        const meanLatency =\n          latencies.reduce((acc, latency) => acc + latency, 0) /\n          latencies.length\n        const latencyScore = 1 - meanLatency / maxLatency\n\n        const successes = samples.map((sample) => sample[i].success)\n        const stabilityScore =\n          successes.reduce((acc, success) => acc + success, 0) /\n          successes.length\n\n        if (stabilityScore === 0) return [0, i]\n        return [\n          latencyWeight * latencyScore + stabilityWeight * stabilityScore,\n          i,\n        ]\n      })\n      .sort((a, b) => b[0] - a[0])\n\n    // 5. Sort the Transports by score.\n    onTransports(scores.map(([, i]) => transports[i]))\n\n    // 6. Wait, and then rank again.\n    await wait(interval)\n    rankTransports_()\n  }\n  rankTransports_()\n}\n", "import { BaseError } from './base.js'\n\nexport class UrlRequiredError extends BaseError {\n  constructor() {\n    super(\n      'No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.',\n      {\n        docsPath: '/docs/clients/intro',\n      },\n    )\n  }\n}\n", "export function withTimeout<TData>(\n  fn: ({ signal }: { signal?: AbortController['signal'] }) => Promise<TData>,\n  {\n    errorInstance,\n    timeout,\n    signal,\n  }: {\n    // The error instance to throw when the timeout is reached.\n    errorInstance: Error\n    // The timeout (in ms).\n    timeout: number\n    // Whether or not the timeout should use an abort signal.\n    signal?: boolean\n  },\n): Promise<TData> {\n  return new Promise((resolve, reject) => {\n    ;(async () => {\n      let timeoutId!: NodeJS.Timeout\n      try {\n        const controller = new AbortController()\n        if (timeout > 0) {\n          timeoutId = setTimeout(() => {\n            if (signal) {\n              controller.abort()\n            } else {\n              reject(errorInstance)\n            }\n          }, timeout)\n        }\n        resolve(await fn({ signal: controller?.signal }))\n      } catch (err) {\n        if ((err as Error).name === 'AbortError') reject(errorInstance)\n        reject(err)\n      } finally {\n        clearTimeout(timeoutId)\n      }\n    })()\n  })\n}\n", "import type { MessageEvent, WebSocket } from 'isomorphic-ws'\n\nimport {\n  HttpRequestError,\n  TimeoutError,\n  WebSocketRequestError,\n} from '../errors/request.js'\n\nimport { createBatchScheduler } from './promise/createBatchScheduler.js'\nimport { withTimeout } from './promise/withTimeout.js'\nimport { stringify } from './stringify.js'\n\nlet id = 0\n\ntype SuccessResult<T> = {\n  method?: never\n  result: T\n  error?: never\n}\ntype ErrorResult<T> = {\n  method?: never\n  result?: never\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never\n  result?: never\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never\n      }\n    | {\n        result?: never\n        error: TError\n      }\n  )\n}\n\nexport type RpcRequest = { method: string; params?: any }\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n///////////////////////////////////////////////////\n// HTTP\n\nexport type HttpOptions<TBody extends RpcRequest | RpcRequest[] = RpcRequest,> =\n  {\n    // The RPC request body.\n    body: TBody\n    // Request configuration to pass to `fetch`.\n    fetchOptions?: Omit<RequestInit, 'body'>\n    // The timeout (in ms) for the request.\n    timeout?: number\n  }\n\nexport type HttpReturnType<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = TBody extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nasync function http<TBody extends RpcRequest | RpcRequest[]>(\n  url: string,\n  { body, fetchOptions = {}, timeout = 10_000 }: HttpOptions<TBody>,\n): Promise<HttpReturnType<TBody>> {\n  const { headers, method, signal: signal_ } = fetchOptions\n  try {\n    const response = await withTimeout(\n      async ({ signal }) => {\n        const response = await fetch(url, {\n          ...fetchOptions,\n          body: Array.isArray(body)\n            ? stringify(\n                body.map((body) => ({\n                  jsonrpc: '2.0',\n                  id: id++,\n                  ...body,\n                })),\n              )\n            : stringify({ jsonrpc: '2.0', id: id++, ...body }),\n          headers: {\n            ...headers,\n            'Content-Type': 'application/json',\n          },\n          method: method || 'POST',\n          signal: signal_ || (timeout > 0 ? signal : undefined),\n        })\n        return response\n      },\n      {\n        errorInstance: new TimeoutError({ body, url }),\n        timeout,\n        signal: true,\n      },\n    )\n\n    let data\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url,\n      })\n    }\n\n    return data\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err\n    if (err instanceof TimeoutError) throw err\n    throw new HttpRequestError({\n      body,\n      details: (err as Error).message,\n      url,\n    })\n  }\n}\n\n///////////////////////////////////////////////////\n// WebSocket\n\ntype Id = string | number\ntype CallbackFn = (message: any) => void\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type Socket = WebSocket & {\n  requests: CallbackMap\n  subscriptions: CallbackMap\n}\n\nconst sockets = /*#__PURE__*/ new Map<string, Socket>()\n\nexport async function getSocket(url_: string) {\n  const url = new URL(url_)\n  const urlKey = url.toString()\n\n  let socket = sockets.get(urlKey)\n\n  // If the socket already exists, return it.\n  if (socket) return socket\n\n  const { schedule } = createBatchScheduler<undefined, [Socket]>({\n    id: urlKey,\n    fn: async () => {\n      let WebSocket = await import('isomorphic-ws')\n      // Workaround for Vite.\n      // https://github.com/vitejs/vite/issues/9703\n      // TODO: Remove when issue is resolved.\n      if (\n        (WebSocket as unknown as { default?: typeof WebSocket }).default\n          ?.constructor\n      )\n        WebSocket = (WebSocket as unknown as { default: typeof WebSocket })\n          .default\n      else WebSocket = WebSocket.WebSocket\n\n      const webSocket = new WebSocket(url)\n\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      const onMessage: (event: MessageEvent) => void = ({ data }) => {\n        const message: RpcResponse = JSON.parse(data as string)\n        const isSubscription = message.method === 'eth_subscription'\n        const id = isSubscription ? message.params.subscription : message.id\n        const cache = isSubscription ? subscriptions : requests\n        const callback = cache.get(id)\n        if (callback) callback({ data })\n        if (!isSubscription) cache.delete(id)\n      }\n      const onClose = () => {\n        sockets.delete(urlKey)\n        webSocket.removeEventListener('close', onClose)\n        webSocket.removeEventListener('message', onMessage)\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose)\n      webSocket.addEventListener('message', onMessage)\n\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return\n          webSocket.onopen = resolve\n          webSocket.onerror = reject\n        })\n      }\n\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions,\n      })\n      sockets.set(urlKey, socket)\n\n      return [socket]\n    },\n  })\n\n  const [_, [socket_]] = await schedule()\n  return socket_\n}\n\nexport type WebSocketOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The callback to invoke on response. */\n  onResponse?: (message: RpcResponse) => void\n}\n\nexport type WebSocketReturnType = Socket\n\nfunction webSocket(\n  socket: Socket,\n  { body, onResponse }: WebSocketOptions,\n): WebSocketReturnType {\n  if (\n    socket.readyState === socket.CLOSED ||\n    socket.readyState === socket.CLOSING\n  )\n    throw new WebSocketRequestError({\n      body,\n      url: socket.url,\n      details: 'Socket is closed.',\n    })\n\n  const id_ = id++\n\n  const callback = ({ data }: { data: any }) => {\n    const message: RpcResponse = JSON.parse(data)\n\n    if (typeof message.id === 'number' && id_ !== message.id) return\n\n    onResponse?.(message)\n\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback)\n    }\n\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0])\n    }\n  }\n  socket.requests.set(id_, callback)\n\n  socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }))\n\n  return socket\n}\n\nexport type WebSocketAsyncOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The timeout (in ms) for the request. */\n  timeout?: number\n}\n\nexport type WebSocketAsyncReturnType = RpcResponse\n\nasync function webSocketAsync(\n  socket: Socket,\n  { body, timeout = 10_000 }: WebSocketAsyncOptions,\n): Promise<WebSocketAsyncReturnType> {\n  return withTimeout(\n    () =>\n      new Promise<RpcResponse>((onResponse) =>\n        rpc.webSocket(socket, {\n          body,\n          onResponse,\n        }),\n      ),\n    {\n      errorInstance: new TimeoutError({ body, url: socket.url }),\n      timeout,\n    },\n  )\n}\n\n///////////////////////////////////////////////////\n\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync,\n}\n", "import { RpcRequestError } from '../../errors/request.js'\nimport { UrlRequiredError } from '../../errors/transport.js'\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js'\nimport { type HttpOptions, type RpcRequest, rpc } from '../../utils/rpc.js'\n\nimport {\n  type Transport,\n  type TransportConfig,\n  createTransport,\n} from './createTransport.js'\n\nexport type BatchOptions = {\n  /** The maximum number of JSON-RPC requests to send in a batch. @default 1_000 */\n  batchSize?: number\n  /** The maximum number of milliseconds to wait before sending a batch. @default 0 */\n  wait?: number\n}\n\nexport type HttpTransportConfig = {\n  /**\n   * Whether to enable Batch JSON-RPC.\n   * @link https://www.jsonrpc.org/specification#batch\n   */\n  batch?: boolean | BatchOptions\n  /**\n   * Request configuration to pass to `fetch`.\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/fetch\n   */\n  fetchOptions?: HttpOptions['fetchOptions']\n  /** The key of the HTTP transport. */\n  key?: TransportConfig['key']\n  /** The name of the HTTP transport. */\n  name?: TransportConfig['name']\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount']\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay']\n  /** The timeout (in ms) for the HTTP request. Default: 10_000 */\n  timeout?: TransportConfig['timeout']\n}\n\nexport type HttpTransport = Transport<\n  'http',\n  {\n    url?: string\n  }\n>\n\n/**\n * @description Creates a HTTP transport that connects to a JSON-RPC API.\n */\nexport function http(\n  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */\n  url?: string,\n  config: HttpTransportConfig = {},\n): HttpTransport {\n  const {\n    batch,\n    fetchOptions,\n    key = 'http',\n    name = 'HTTP JSON-RPC',\n    retryDelay,\n  } = config\n  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {\n    const { batchSize = 1000, wait = 0 } =\n      typeof batch === 'object' ? batch : {}\n    const retryCount = config.retryCount ?? retryCount_\n    const timeout = timeout_ ?? config.timeout ?? 10_000\n    const url_ = url || chain?.rpcUrls.default.http[0]\n    if (!url_) throw new UrlRequiredError()\n    return createTransport(\n      {\n        key,\n        name,\n        async request({ method, params }) {\n          const body = { method, params }\n\n          const { schedule } = createBatchScheduler({\n            id: `${url}`,\n            wait,\n            shouldSplitBatch(requests) {\n              return requests.length > batchSize\n            },\n            fn: (body: RpcRequest[]) =>\n              rpc.http(url_, {\n                body,\n                fetchOptions,\n                timeout,\n              }),\n          })\n\n          const fn = async (body: RpcRequest) =>\n            batch\n              ? schedule(body)\n              : [await rpc.http(url_, { body, fetchOptions, timeout })]\n\n          const [{ error, result }] = await fn(body)\n          if (error)\n            throw new RpcRequestError({\n              body,\n              error,\n              url: url_,\n            })\n          return result\n        },\n        retryCount,\n        retryDelay,\n        timeout,\n        type: 'http',\n      },\n      {\n        url,\n      },\n    )\n  }\n}\n", "import { panicReasons } from '../../constants/solidity.js'\nimport { BaseError } from '../../errors/base.js'\nimport { ContractFunctionRevertedError } from '../../errors/contract.js'\n\n/*\n * @description Checks if error is a valid null result UniversalResolver error\n */\nexport function isNullUniversalResolverError(\n  err: unknown,\n  callType: 'resolve' | 'reverse',\n): boolean {\n  if (!(err instanceof BaseError)) return false\n  const cause = err.walk((e) => e instanceof ContractFunctionRevertedError)\n  if (!(cause instanceof ContractFunctionRevertedError)) return false\n  if (cause.data?.errorName === 'ResolverNotFound') return true\n  if (cause.data?.errorName === 'ResolverWildcardNotSupported') return true\n  // Backwards compatibility for older UniversalResolver contracts\n  if (\n    cause.reason?.includes(\n      'Wildcard on non-extended resolvers is not supported',\n    )\n  )\n    return true\n  // No primary name set for address.\n  if (callType === 'reverse' && cause.reason === panicReasons[50]) return true\n  return false\n}\n", "export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n", "import type { TypedData, TypedDataParameter, TypedDataType } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport { isAddress } from './address/isAddress.js'\nimport { size } from './data/size.js'\nimport { numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\n\nexport function validateTypedData<\n  TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain,\n  message,\n  primaryType,\n  types: types_,\n}: TypedDataDefinition<TTypedData, TPrimaryType>) {\n  const types = types_ as TypedData\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    value_: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type: type_ } = param\n      const type = type_ as TypedDataType\n      const value = value_[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types['EIP712Domain'] && domain)\n    validateData(types['EIP712Domain'], domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message as Record<string, unknown>)\n  }\n}\n", "import type { Abi, Narrow } from 'abitype'\n\nimport {\n  AbiConstructorNotFoundError,\n  AbiConstructorParamsNotFoundError,\n} from '../../errors/abi.js'\nimport type { GetConstructorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { concatHex } from '../data/concat.js'\n\nimport { encodeAbiParameters } from './encodeAbiParameters.js'\n\nconst docsPath = '/docs/contract/encodeDeployData'\n\nexport type EncodeDeployDataParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = {\n  abi: Narrow<TAbi>\n  bytecode: Hex\n} & GetConstructorArgs<TAbi>\n\nexport function encodeDeployData<TAbi extends Abi | readonly unknown[]>({\n  abi,\n  args,\n  bytecode,\n}: EncodeDeployDataParameters<TAbi>) {\n  if (!args || args.length === 0) return bytecode\n\n  const description = (abi as Abi).find(\n    (x) => 'type' in x && x.type === 'constructor',\n  )\n  if (!description) throw new AbiConstructorNotFoundError({ docsPath })\n  if (!('inputs' in description))\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n  if (!description.inputs || description.inputs.length === 0)\n    throw new AbiConstructorParamsNotFoundError({ docsPath })\n\n  const data = encodeAbiParameters(\n    description.inputs,\n    args as readonly unknown[],\n  )\n  return concatHex([bytecode, data!])\n}\n", "// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { encodeAbiParameters } from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { toHex } from '../encoding/toHex.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { validateTypedData } from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n> = TypedDataDefinition<TTypedData, TPrimaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport function hashTypedData<\n  TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain: domain_,\n  message,\n  primaryType,\n  types: types_,\n}: HashTypedDataParameters<TTypedData, TPrimaryType>): HashTypedDataReturnType {\n  const domain: TypedDataDomain = typeof domain_ === 'undefined' ? {} : domain_\n  const types = {\n    EIP712Domain: [\n      typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n      domain?.version && { name: 'version', type: 'string' },\n      typeof domain?.chainId === 'number' && {\n        name: 'chainId',\n        type: 'uint256',\n      },\n      domain?.verifyingContract && {\n        name: 'verifyingContract',\n        type: 'address',\n      },\n      domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean),\n    ...(types_ as TTypedData),\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as TypedDataDefinition)\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain') {\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType: primaryType as string,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n  }\n\n  return keccak256(concat(parts))\n}\n\nfunction hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\nfunction hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n", "import type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { concat } from '../data/concat.js'\nimport { stringToBytes, toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessage<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport function hashMessage<TTo extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: TTo,\n): HashMessage<TTo> {\n  const messageBytes = (() => {\n    if (typeof message === 'string') return stringToBytes(message)\n    if (message.raw instanceof Uint8Array) return message.raw\n    return toBytes(message.raw)\n  })()\n  const prefixBytes = stringToBytes(\n    `\\x19Ethereum Signed Message:\\n${messageBytes.length}`,\n  )\n  return keccak256(concat([prefixBytes, messageBytes]), to_)\n}\n", "export function parseUnits(value: string, decimals: number) {\n  let [integer, fraction = '0'] = value.split('.')\n\n  const negative = integer.startsWith('-')\n  if (negative) integer = integer.slice(1)\n\n  // trim leading zeros.\n  fraction = fraction.replace(/(0+)$/, '')\n\n  // round off if the fraction is larger than the number of decimals.\n  if (decimals === 0) {\n    if (Math.round(Number(`.${fraction}`)) === 1)\n      integer = `${BigInt(integer) + 1n}`\n    fraction = ''\n  } else if (fraction.length > decimals) {\n    const [left, unit, right] = [\n      fraction.slice(0, decimals - 1),\n      fraction.slice(decimals - 1, decimals),\n      fraction.slice(decimals),\n    ]\n\n    const rounded = Math.round(Number(`${unit}.${right}`))\n    if (rounded > 9)\n      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0')\n    else fraction = `${left}${rounded}`\n\n    if (fraction.length > decimals) {\n      fraction = fraction.slice(1)\n      integer = `${BigInt(integer) + 1n}`\n    }\n\n    fraction = fraction.slice(0, decimals)\n  } else {\n    fraction = fraction.padEnd(decimals, '0')\n  }\n\n  return BigInt(`${negative ? '-' : ''}${integer}${fraction}`)\n}\n", "import { gweiUnits } from '../../constants/unit.js'\n\nimport { parseUnits } from './parseUnits.js'\n\nexport function parseGwei(ether: string, unit: 'wei' = 'wei') {\n  return parseUnits(ether, gweiUnits[unit])\n}\n", "import type { Hex } from '../../index.js'\nimport { isHex } from '../index.js'\n\nexport function encodedLabelToLabelhash(label: string): Hex | null {\n  if (label.length !== 66) return null\n  if (label.indexOf('[') !== 0) return null\n  if (label.indexOf(']') !== 65) return null\n  const hash = `0x${label.slice(1, 65)}`\n  if (!isHex(hash)) return null\n  return hash\n}\n", "import { concat } from '../data/concat.js'\nimport { stringToBytes, toBytes } from '../encoding/toBytes.js'\nimport { bytesToHex } from '../encoding/toHex.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { encodedLabelToLabelhash } from './encodedLabelToLabelhash.js'\n\n/**\n * @description Hashes ENS name\n *\n * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @example\n * namehash('wagmi-dev.eth')\n * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n *\n * @link https://eips.ethereum.org/EIPS/eip-137\n */\nexport function namehash(name: string) {\n  let result = new Uint8Array(32).fill(0)\n  if (!name) return bytesToHex(result)\n\n  const labels = name.split('.')\n  // Iterate in reverse order building up hash\n  for (let i = labels.length - 1; i >= 0; i -= 1) {\n    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i])\n    const hashed = hashFromEncodedLabel\n      ? toBytes(hashFromEncodedLabel)\n      : keccak256(stringToBytes(labels[i]), 'bytes')\n    result = keccak256(concat([result, hashed]), 'bytes')\n  }\n\n  return bytesToHex(result)\n}\n", "import type { Hex } from '../../index.js'\n\nexport function encodeLabelhash(hash: Hex): `[${string}]` {\n  return `[${hash.slice(2)}]`\n}\n", "import { stringToBytes } from '../encoding/toBytes.js'\nimport { bytesToHex } from '../encoding/toHex.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { encodedLabelToLabelhash } from './encodedLabelToLabelhash.js'\n\n/**\n * @description Hashes ENS label\n *\n * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @example\n * labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n */\nexport function labelhash(label: string) {\n  const result = new Uint8Array(32).fill(0)\n  if (!label) return bytesToHex(result)\n  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label))\n}\n", "// Adapted from https://github.com/mafintosh/dns-packet\nimport type { ByteArray } from '../../types/misc.js'\nimport { stringToBytes } from '../encoding/toBytes.js'\nimport { encodeLabelhash } from './encodeLabelhash.js'\nimport { labelhash } from './labelhash.js'\n\n/*\n * @description Encodes a DNS packet into a ByteArray containing a UDP payload.\n */\nexport function packetToBytes(packet: string): ByteArray {\n  // strip leading and trailing `.`\n  const value = packet.replace(/^\\.|\\.$/gm, '')\n  if (value.length === 0) return new Uint8Array(1)\n\n  const bytes = new Uint8Array(stringToBytes(value).byteLength + 2)\n\n  let offset = 0\n  const list = value.split('.')\n  for (let i = 0; i < list.length; i++) {\n    let encoded = stringToBytes(list[i])\n    // if the length is > 255, make the encoded label value a labelhash\n    // this is compatible with the universal resolver\n    if (encoded.byteLength > 255)\n      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])))\n    bytes[offset] = encoded.length\n    bytes.set(encoded, offset + 1)\n    offset += encoded.length + 1\n  }\n\n  if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1)\n\n  return bytes\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  addressResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { trim } from '../../utils/data/trim.js'\nimport { toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { namehash } from '../../utils/ens/namehash.js'\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsAddressParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENSIP-9 compliant coinType used to resolve addresses for other chains */\n    coinType?: number\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsAddressReturnType = Address | null\n\n/**\n * Gets address for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAddressParameters}\n * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAddress, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAddress = await getEnsAddress(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n */\nexport async function getEnsAddress<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    coinType,\n    name,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsAddressParameters,\n): Promise<GetEnsAddressReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  try {\n    const functionData = encodeFunctionData({\n      abi: addressResolverAbi,\n      functionName: 'addr',\n      ...(coinType != null\n        ? { args: [namehash(name), BigInt(coinType)] }\n        : { args: [namehash(name)] }),\n    })\n\n    const res = await readContract(client, {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [toHex(packetToBytes(name)), functionData],\n      blockNumber,\n      blockTag,\n    })\n\n    if (res[0] === '0x') return null\n\n    const address = trim(\n      decodeFunctionResult({\n        abi: addressResolverAbi,\n        args: coinType != null ? [namehash(name), BigInt(coinType)] : undefined,\n        functionName: 'addr',\n        data: res[0],\n      }),\n    )\n\n    if (address === '0x') return null\n    if (trim(address) === '0x00') return null\n    return address\n  } catch (err) {\n    if (isNullUniversalResolverError(err, 'resolve')) return null\n    throw err\n  }\n}\n", "import { BaseError } from './base.js'\n\nexport class EnsAvatarInvalidMetadataError extends BaseError {\n  override name = 'EnsAvatarInvalidMetadataError'\n  constructor({ data }: { data: any }) {\n    super(\n      'Unable to extract image from metadata. The metadata may be malformed or invalid.',\n      {\n        metaMessages: [\n          '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',\n          '',\n          `Provided data: ${JSON.stringify(data)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport class EnsAvatarInvalidNftUriError extends BaseError {\n  override name = 'EnsAvatarInvalidNftUriError'\n  constructor({ reason }: { reason: string }) {\n    super(`ENS NFT avatar URI is invalid. ${reason}`)\n  }\n}\n\nexport class EnsAvatarUriResolutionError extends BaseError {\n  override name = 'EnsAvatarUriResolutionError'\n  constructor({ uri }: { uri: string }) {\n    super(\n      `Unable to resolve ENS avatar URI \"${uri}\". The URI may be malformed, invalid, or does not respond with a valid image.`,\n    )\n  }\n}\n\nexport class EnsAvatarUnsupportedNamespaceError extends BaseError {\n  override name = 'EnsAvatarUnsupportedNamespaceError'\n  constructor({ namespace }: { namespace: string }) {\n    super(\n      `ENS NFT avatar namespace \"${namespace}\" is not supported. Must be \"erc721\" or \"erc1155\".`,\n    )\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport { readContract } from '../../../actions/public/readContract.js'\nimport type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport {\n  EnsAvatarInvalidMetadataError,\n  EnsAvatarInvalidNftUriError,\n  EnsAvatarUnsupportedNamespaceError,\n  EnsAvatarUriResolutionError,\n} from '../../../errors/ens.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\ntype UriItem = {\n  uri: string\n  isOnChain: boolean\n  isEncoded: boolean\n}\n\nconst networkRegex =\n  /(?<protocol>https?:\\/\\/[^\\/]*|ipfs:\\/|ipns:\\/|ar:\\/)?(?<root>\\/)?(?<subpath>ipfs\\/|ipns\\/)?(?<target>[\\w\\-.]+)(?<subtarget>\\/.*)?/\nconst ipfsHashRegex =\n  /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\/(?<target>[\\w\\-.]+))?(?<subtarget>\\/.*)?$/\nconst base64Regex = /^data:([a-zA-Z\\-/+]*);base64,([^\"].*)/\nconst dataURIRegex = /^data:([a-zA-Z\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/\n\nexport async function isImageUri(uri: string) {\n  try {\n    const res = await fetch(uri, { method: 'HEAD' })\n    // retrieve content type header to check if content is image\n    if (res.status === 200) {\n      const contentType = res.headers.get('content-type')\n      return contentType?.startsWith('image/')\n    }\n    return false\n  } catch (error: any) {\n    // if error is not cors related then fail\n    if (typeof error === 'object' && typeof error.response !== 'undefined') {\n      return false\n    }\n    // fail in NodeJS, since the error is not cors but any other network issue\n    // rome-ignore lint/suspicious/noPrototypeBuiltins:\n    if (!globalThis.hasOwnProperty('Image')) return false\n    // in case of cors, use image api to validate if given url is an actual image\n    return new Promise((resolve) => {\n      const img = new Image()\n      img.onload = () => {\n        resolve(true)\n      }\n      img.onerror = () => {\n        resolve(false)\n      }\n      img.src = uri\n    })\n  }\n}\n\nexport function getGateway(custom: string | undefined, defaultGateway: string) {\n  if (!custom) return defaultGateway\n  if (custom.endsWith('/')) return custom.slice(0, -1)\n  return custom\n}\n\nexport function resolveAvatarUri({\n  uri,\n  gatewayUrls,\n}: {\n  uri: string\n  gatewayUrls?: AssetGatewayUrls | undefined\n}): UriItem {\n  const isEncoded = base64Regex.test(uri)\n  if (isEncoded) return { uri, isOnChain: true, isEncoded }\n\n  const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io')\n  const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net')\n\n  const networkRegexMatch = uri.match(networkRegex)\n  const {\n    protocol,\n    subpath,\n    target,\n    subtarget = '',\n  } = networkRegexMatch?.groups || {}\n\n  const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/'\n  const isIPFS =\n    protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri)\n\n  if (uri.startsWith('http') && !isIPNS && !isIPFS) {\n    let replacedUri = uri\n    if (gatewayUrls?.arweave)\n      replacedUri = uri.replace(/https:\\/\\/arweave.net/g, gatewayUrls?.arweave)\n    return { uri: replacedUri, isOnChain: false, isEncoded: false }\n  }\n\n  if ((isIPNS || isIPFS) && target) {\n    return {\n      uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  } else if (protocol === 'ar:/' && target) {\n    return {\n      uri: `${arweaveGateway}/${target}${subtarget || ''}`,\n      isOnChain: false,\n      isEncoded: false,\n    }\n  }\n\n  let parsedUri = uri.replace(dataURIRegex, '')\n  if (parsedUri.startsWith('<svg')) {\n    // if svg, base64 encode\n    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`\n  }\n\n  if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {\n    return {\n      uri: parsedUri,\n      isOnChain: true,\n      isEncoded: false,\n    }\n  }\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\nexport function getJsonImage(data: any) {\n  // validation check for json data, must include one of theses properties\n  if (\n    typeof data !== 'object' ||\n    (!('image' in data) && !('image_url' in data) && !('image_data' in data))\n  ) {\n    throw new EnsAvatarInvalidMetadataError({ data })\n  }\n\n  return data.image || data.image_url || data.image_data\n}\n\nexport async function getMetadataAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  try {\n    const res = await fetch(uri).then((res) => res.json())\n    const image = await parseAvatarUri({\n      gatewayUrls,\n      uri: getJsonImage(res),\n    })\n    return image\n  } catch {\n    throw new EnsAvatarUriResolutionError({ uri })\n  }\n}\n\nexport async function parseAvatarUri({\n  gatewayUrls,\n  uri,\n}: {\n  gatewayUrls?: AssetGatewayUrls | undefined\n  uri: string\n}): Promise<string> {\n  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls })\n  if (isOnChain) return resolvedURI\n\n  // check if resolvedURI is an image, if it is return the url\n  const isImage = await isImageUri(resolvedURI)\n  if (isImage) return resolvedURI\n\n  throw new EnsAvatarUriResolutionError({ uri })\n}\n\ntype ParsedNft = {\n  chainID: number\n  namespace: string\n  contractAddress: Address\n  tokenID: string\n}\n\nexport function parseNftUri(uri_: string): ParsedNft {\n  let uri = uri_\n  // parse valid nft spec (CAIP-22/CAIP-29)\n  // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs\n  if (uri.startsWith('did:nft:')) {\n    // convert DID to CAIP\n    uri = uri.replace('did:nft:', '').replace(/_/g, '/')\n  }\n\n  const [reference, asset_namespace, tokenID] = uri.split('/')\n  const [eip_namespace, chainID] = reference.split(':')\n  const [erc_namespace, contractAddress] = asset_namespace.split(':')\n\n  if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' })\n  if (!chainID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' })\n  if (!contractAddress)\n    throw new EnsAvatarInvalidNftUriError({\n      reason: 'Contract address not found',\n    })\n  if (!tokenID)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' })\n  if (!erc_namespace)\n    throw new EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' })\n\n  return {\n    chainID: parseInt(chainID),\n    namespace: erc_namespace.toLowerCase(),\n    contractAddress: contractAddress as Address,\n    tokenID,\n  }\n}\n\nexport async function getNftTokenUri<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { nft }: { nft: ParsedNft },\n) {\n  if (nft.namespace === 'erc721') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'tokenURI',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: 'tokenId', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'tokenURI',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  if (nft.namespace === 'erc1155') {\n    return readContract(client, {\n      address: nft.contractAddress,\n      abi: [\n        {\n          name: 'uri',\n          type: 'function',\n          stateMutability: 'view',\n          inputs: [{ name: '_id', type: 'uint256' }],\n          outputs: [{ name: '', type: 'string' }],\n        },\n      ],\n      functionName: 'uri',\n      args: [BigInt(nft.tokenID)],\n    })\n  }\n  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace })\n}\n", "import type { Client } from '../../../clients/createClient.js'\nimport type { Transport } from '../../../clients/transports/createTransport.js'\nimport type { Chain } from '../../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../../types/ens.js'\n\nimport {\n  getJsonImage,\n  getMetadataAvatarUri,\n  getNftTokenUri,\n  parseAvatarUri,\n  parseNftUri,\n  resolveAvatarUri,\n} from './utils.js'\n\nexport async function parseAvatarRecord<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls\n    record: string\n  },\n): Promise<string> {\n  if (/eip155:/i.test(record))\n    return parseNftAvatarUri(client, { gatewayUrls, record })\n  return parseAvatarUri({ uri: record, gatewayUrls })\n}\n\nasync function parseNftAvatarUri<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    gatewayUrls,\n    record,\n  }: {\n    gatewayUrls?: AssetGatewayUrls\n    record: string\n  },\n): Promise<string> {\n  // parse NFT URI into properties\n  const nft = parseNftUri(record)\n  // fetch tokenURI from the NFT contract\n  const nftUri = await getNftTokenUri(client, { nft })\n  // resolve the URI from the fetched tokenURI\n  const {\n    uri: resolvedNftUri,\n    isOnChain,\n    isEncoded,\n  } = resolveAvatarUri({ uri: nftUri, gatewayUrls })\n\n  // if the resolved URI is on chain, return the data\n  if (\n    isOnChain &&\n    (resolvedNftUri.includes('data:application/json;base64,') ||\n      resolvedNftUri.startsWith('{'))\n  ) {\n    const encodedJson = isEncoded\n      ? // if it is encoded, decode it\n        atob(resolvedNftUri.replace('data:application/json;base64,', ''))\n      : // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)\n        resolvedNftUri\n\n    const decoded = JSON.parse(encodedJson)\n    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls })\n  }\n\n  let uriTokenId = nft.tokenID\n  if (nft.namespace === 'erc1155')\n    uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0')\n\n  return getMetadataAvatarUri({\n    gatewayUrls,\n    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),\n  })\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  textResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { namehash } from '../../utils/ens/namehash.js'\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsTextParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get Text for. */\n    name: string\n    /** Text record to retrieve. */\n    key: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsTextReturnType = string | null\n\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wagmi-dev.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wagmi_sh'\n */\nexport async function getEnsText<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    name,\n    key,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsTextParameters,\n): Promise<GetEnsTextReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  try {\n    const res = await readContract(client, {\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: textResolverAbi,\n          functionName: 'text',\n          args: [namehash(name), key],\n        }),\n      ],\n      blockNumber,\n      blockTag,\n    })\n\n    if (res[0] === '0x') return null\n\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0],\n    })\n\n    return record === '' ? null : record\n  } catch (err) {\n    if (isNullUniversalResolverError(err, 'resolve')) return null\n    throw err\n  }\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { AssetGatewayUrls } from '../../types/ens.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { parseAvatarRecord } from '../../utils/ens/avatar/parseAvatarRecord.js'\n\nimport { type GetEnsTextParameters, getEnsText } from './getEnsText.js'\n\nexport type GetEnsAvatarParameters = Prettify<\n  Omit<GetEnsTextParameters, 'key'> & {\n    /** Gateway urls to resolve IPFS and/or Arweave assets. */\n    gatewayUrls?: AssetGatewayUrls\n  }\n>\n\nexport type GetEnsAvatarReturnType = string | null\n\n/**\n * Gets the avatar of an ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsAvatarParameters}\n * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsAvatar, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensAvatar = await getEnsAvatar(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n */\nexport async function getEnsAvatar<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    gatewayUrls,\n    name,\n    universalResolverAddress,\n  }: GetEnsAvatarParameters,\n): Promise<GetEnsAvatarReturnType> {\n  const record = await getEnsText(client, {\n    blockNumber,\n    blockTag,\n    key: 'avatar',\n    name,\n    universalResolverAddress,\n  })\n  if (!record) return null\n  try {\n    return await parseAvatarRecord(client, { record, gatewayUrls })\n  } catch {\n    return null\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalResolverReverseAbi } from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsNameParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Address to get ENS name for. */\n    address: Address\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsNameReturnType = string | null\n\n/**\n * Gets primary name for specified address.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsName.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsNameParameters}\n * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsName } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const ensName = await getEnsName(client, {\n *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n * })\n * // 'wagmi-dev.eth'\n */\nexport async function getEnsName<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    blockNumber,\n    blockTag,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsNameParameters,\n): Promise<GetEnsNameReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`\n  try {\n    const res = await readContract(client, {\n      address: universalResolverAddress,\n      abi: universalResolverReverseAbi,\n      functionName: 'reverse',\n      args: [toHex(packetToBytes(reverseNode))],\n      blockNumber,\n      blockTag,\n    })\n    return res[0]\n  } catch (err) {\n    if (isNullUniversalResolverError(err, 'reverse')) return null\n    throw err\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { toHex } from '../../utils/encoding/toHex.js'\nimport { packetToBytes } from '../../utils/ens/packetToBytes.js'\nimport {\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsResolverParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** Name to get the address for. */\n    name: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsResolverReturnType = Address\n\n/**\n * Gets resolver for ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n *\n * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsResolverParameters}\n * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsResolver, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const resolverAddress = await getEnsResolver(client, {\n *   name: normalize('wagmi-dev.eth'),\n * })\n * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n */\nexport async function getEnsResolver<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    name,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsResolverParameters,\n) {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  const [resolverAddress] = await readContract(client, {\n    address: universalResolverAddress,\n    abi: [\n      {\n        inputs: [{ type: 'bytes' }],\n        name: 'findResolver',\n        outputs: [{ type: 'address' }, { type: 'bytes32' }],\n        stateMutability: 'view',\n        type: 'function',\n      },\n    ],\n    functionName: 'findResolver',\n    args: [toHex(packetToBytes(name))],\n    blockNumber,\n    blockTag,\n  })\n  return resolverAddress\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateBlockFilterReturnType = Filter<'block'>\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).\n *\n * - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html\n * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createBlockFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createBlockFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n */\nexport async function createBlockFilter<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n): Promise<CreateBlockFilterReturnType> {\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newBlockFilter',\n  })\n  const id = await client.request({\n    method: 'eth_newBlockFilter',\n  })\n  return { id, request: getRequest(id), type: 'block' }\n}\n", "import type { AbiEvent, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hex, LogTopic } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type EncodeEventTopicsParameters,\n  encodeEventTopics,\n} from '../../utils/abi/encodeEventTopics.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreateEventFilterParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  _Args extends\n    | MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n    | undefined = undefined,\n> = {\n  address?: Address | Address[]\n  fromBlock?: TFromBlock | BlockNumber | BlockTag\n  toBlock?: TToBlock | BlockNumber | BlockTag\n} & (MaybeExtractEventArgsFromAbi<\n  TAbiEvents,\n  _EventName\n> extends infer TEventFilterArgs\n  ?\n      | {\n          args:\n            | TEventFilterArgs\n            | (_Args extends TEventFilterArgs ? _Args : never)\n          event: Narrow<TAbiEvent>\n          events?: never\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: TStrict\n        }\n      | {\n          args?: never\n          event?: Narrow<TAbiEvent>\n          events?: never\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: TStrict\n        }\n      | {\n          args?: never\n          event?: never\n          events: Narrow<TAbiEvents>\n          /**\n           * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n           * @default false\n           */\n          strict?: TStrict\n        }\n      | {\n          args?: never\n          event?: never\n          events?: never\n          strict?: never\n        }\n  : {\n      args?: never\n      event?: never\n      events?: never\n      strict?: never\n    })\n\nexport type CreateEventFilterReturnType<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  _Args extends\n    | MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n    | undefined = undefined,\n> = Prettify<\n  Filter<'event', TAbiEvents, _EventName, _Args, TStrict, TFromBlock, TToBlock>\n>\n\n/**\n * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).\n *\n * - Docs: https://viem.sh/docs/actions/public/createEventFilter.html\n * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n *\n * @param client - Client to use\n * @param parameters - {@link CreateEventFilterParameters}\n * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateEventFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n * })\n */\nexport async function createEventFilter<\n  TChain extends Chain | undefined,\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber<bigint> | BlockTag | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n  _Args extends\n    | MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n    | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    args,\n    event,\n    events: events_,\n    fromBlock,\n    strict,\n    toBlock,\n  }: CreateEventFilterParameters<\n    TAbiEvent,\n    TAbiEvents,\n    TStrict,\n    TFromBlock,\n    TToBlock,\n    _EventName,\n    _Args\n  > = {} as any,\n): Promise<\n  CreateEventFilterReturnType<\n    TAbiEvent,\n    TAbiEvents,\n    TStrict,\n    TFromBlock,\n    TToBlock,\n    _EventName,\n    _Args\n  >\n> {\n  const events = events_ ?? (event ? [event] : undefined)\n\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newFilter',\n  })\n\n  let topics: LogTopic[] = []\n  if (events) {\n    topics = [\n      (events as AbiEvent[]).flatMap((event) =>\n        encodeEventTopics({\n          abi: [event],\n          eventName: (event as AbiEvent).name,\n          args,\n        } as EncodeEventTopicsParameters),\n      ),\n    ]\n    if (event) topics = topics[0] as LogTopic[]\n  }\n\n  const id: Hex = await client.request({\n    method: 'eth_newFilter',\n    params: [\n      {\n        address,\n        fromBlock:\n          typeof fromBlock === 'bigint' ? numberToHex(fromBlock) : fromBlock,\n        toBlock: typeof toBlock === 'bigint' ? numberToHex(toBlock) : toBlock,\n        ...(topics.length ? { topics } : {}),\n      },\n    ],\n  })\n\n  return {\n    abi: events,\n    args,\n    eventName: event ? (event as AbiEvent).name : undefined,\n    fromBlock,\n    id,\n    request: getRequest(id),\n    strict,\n    toBlock,\n    type: 'event',\n  } as unknown as CreateEventFilterReturnType<\n    TAbiEvent,\n    TAbiEvents,\n    TStrict,\n    TFromBlock,\n    TToBlock,\n    _EventName,\n    _Args\n  >\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport { createFilterRequestScope } from '../../utils/filters/createFilterRequestScope.js'\n\nexport type CreatePendingTransactionFilterReturnType = Filter<'transaction'>\n\n/**\n * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).\n *\n * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html\n * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)\n *\n * @param client - Client to use\n * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createPendingTransactionFilter } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createPendingTransactionFilter(client)\n * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'transaction' }\n */\nexport async function createPendingTransactionFilter<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n>(\n  client: Client<TTransport, TChain>,\n): Promise<CreatePendingTransactionFilterReturnType> {\n  const getRequest = createFilterRequestScope(client, {\n    method: 'eth_newPendingTransactionFilter',\n  })\n  const id = await client.request({\n    method: 'eth_newPendingTransactionFilter',\n  })\n  return { id, request: getRequest(id), type: 'transaction' }\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetBalanceParameters = {\n  /** The address of the account. */\n  address: Address\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockNumber?: never\n      /** The balance of the account at a block tag. */\n      blockTag?: BlockTag\n    }\n)\n\nexport type GetBalanceReturnType = bigint\n\n/**\n * Returns the balance of an address in wei.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBalance.html\n * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)\n *\n * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html).\n *\n * ```ts\n * const balance = await getBalance(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   blockTag: 'safe'\n * })\n * const balanceAsEther = formatEther(balance)\n * // \"6.942\"\n * ```\n *\n * @param client - Client to use\n * @param parameters - {@link GetBalanceParameters}\n * @returns The balance of the address in wei. {@link GetBalanceReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBalance } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const balance = await getBalance(client, {\n *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n * })\n * // 10000000000000000000000n (wei)\n */\nexport async function getBalance<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { address, blockNumber, blockTag = 'latest' }: GetBalanceParameters,\n): Promise<GetBalanceReturnType> {\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n\n  const balance = await client.request({\n    method: 'eth_getBalance',\n    params: [address, blockNumberHex || blockTag],\n  })\n  return BigInt(balance)\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Quantity } from '../../types/rpc.js'\nimport { hexToNumber } from '../../utils/encoding/fromHex.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetBlockTransactionCountParameters =\n  | {\n      /** Hash of the block. */\n      blockHash?: Hash\n      blockNumber?: never\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      /** The block number. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      /** The block tag. Defaults to 'latest'. */\n      blockTag?: BlockTag\n    }\n\nexport type GetBlockTransactionCountReturnType = number\n\n/**\n * Returns the number of Transactions at a block number, hash, or tag.\n *\n * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html\n * - JSON-RPC Methods:\n *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n *\n * @param client - Client to use\n * @param parameters - {@link GetBlockTransactionCountParameters}\n * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBlockTransactionCount } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const count = await getBlockTransactionCount(client)\n */\nexport async function getBlockTransactionCount<\n  TChain extends Chain | undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag = 'latest',\n  }: GetBlockTransactionCountParameters = {},\n): Promise<GetBlockTransactionCountReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let count: Quantity\n  if (blockHash) {\n    count = await client.request({\n      method: 'eth_getBlockTransactionCountByHash',\n      params: [blockHash],\n    })\n  } else {\n    count = await client.request({\n      method: 'eth_getBlockTransactionCountByNumber',\n      params: [blockNumberHex || blockTag],\n    })\n  }\n\n  return hexToNumber(count)\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetBytecodeParameters = {\n  address: Address\n} & (\n  | {\n      blockNumber?: never\n      blockTag?: BlockTag\n    }\n  | {\n      blockNumber?: bigint\n      blockTag?: never\n    }\n)\n\nexport type GetBytecodeReturnType = Hex | undefined\n\n/**\n * Retrieves the bytecode at an address.\n *\n * - Docs: https://viem.sh/docs/contract/getBytecode.html\n * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n *\n * @param client - Client to use\n * @param parameters - {@link GetBytecodeParameters}\n * @returns The contract's bytecode. {@link GetBytecodeReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getBytecode } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getBytecode(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n * })\n */\nexport async function getBytecode<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { address, blockNumber, blockTag = 'latest' }: GetBytecodeParameters,\n): Promise<GetBytecodeReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const hex = await client.request({\n    method: 'eth_getCode',\n    params: [address, blockNumberHex || blockTag],\n  })\n  if (hex === '0x') return undefined\n  return hex\n}\n", "import type { FeeHistory } from '../../types/fee.js'\nimport type { RpcFeeHistory } from '../../types/rpc.js'\n\nexport function formatFeeHistory(feeHistory: RpcFeeHistory): FeeHistory {\n  return {\n    baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),\n    gasUsedRatio: feeHistory.gasUsedRatio,\n    oldestBlock: BigInt(feeHistory.oldestBlock),\n    reward: feeHistory.reward?.map((reward) =>\n      reward.map((value) => BigInt(value)),\n    ),\n  }\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { FeeHistory } from '../../types/fee.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport { formatFeeHistory } from '../../utils/formatters/feeHistory.js'\n\nexport type GetFeeHistoryParameters = {\n  /**\n   * Number of blocks in the requested range. Between 1 and 1024 blocks can be requested in a single query. Less than requested may be returned if not all blocks are available.\n   */\n  blockCount: number\n  /**\n   * A monotonically increasing list of percentile values to sample from each block's effective priority fees per gas in ascending order, weighted by gas used.\n   */\n  rewardPercentiles: number[]\n} & (\n  | {\n      blockNumber?: never\n      /**\n       * Highest number block of the requested range.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag\n    }\n  | {\n      /** Highest number block of the requested range. */\n      blockNumber?: bigint\n      blockTag?: never\n    }\n)\nexport type GetFeeHistoryReturnType = FeeHistory\n\n/**\n * Returns a collection of historical gas information.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html\n * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n *\n * @param client - Client to use\n * @param parameters - {@link GetFeeHistoryParameters}\n * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getFeeHistory } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const feeHistory = await getFeeHistory(client, {\n *   blockCount: 4,\n *   rewardPercentiles: [25, 75],\n * })\n */\nexport async function getFeeHistory<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockCount,\n    blockNumber,\n    blockTag = 'latest',\n    rewardPercentiles,\n  }: GetFeeHistoryParameters,\n): Promise<GetFeeHistoryReturnType> {\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const feeHistory = await client.request({\n    method: 'eth_feeHistory',\n    params: [\n      numberToHex(blockCount),\n      blockNumberHex || blockTag,\n      rewardPercentiles,\n    ],\n  })\n  return formatFeeHistory(feeHistory)\n}\n", "import type { Abi, AbiEvent, ExtractAbiEvent } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport { decodeEventLog } from '../../utils/abi/decodeEventLog.js'\nimport { formatLog } from '../../utils/formatters/log.js'\n\nexport type GetFilterLogsParameters<\n  TAbi extends Abi | readonly unknown[] | undefined = undefined,\n  TEventName extends string | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n> = {\n  filter: Filter<'event', TAbi, TEventName, any, TStrict, TFromBlock, TToBlock>\n}\nexport type GetFilterLogsReturnType<\n  TAbi extends Abi | readonly unknown[] | undefined = undefined,\n  TEventName extends string | undefined = undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  _AbiEvent extends AbiEvent | undefined = TAbi extends Abi\n    ? TEventName extends string\n      ? ExtractAbiEvent<TAbi, TEventName>\n      : undefined\n    : undefined,\n  _Pending extends boolean =\n    | (TFromBlock extends 'pending' ? true : false)\n    | (TToBlock extends 'pending' ? true : false),\n> = Log<bigint, number, _Pending, _AbiEvent, TStrict, TAbi, TEventName>[]\n\n/**\n * Returns a list of event logs since the filter was created.\n *\n * - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html\n * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n *\n * `getFilterLogs` is only compatible with **event filters**.\n *\n * @param client - Client to use\n * @param parameters - {@link GetFilterLogsParameters}\n * @returns A list of event logs. {@link GetFilterLogsReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbiItem } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { createEventFilter, getFilterLogs } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const filter = await createEventFilter(client, {\n *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n * })\n * const logs = await getFilterLogs(client, { filter })\n */\nexport async function getFilterLogs<\n  TChain extends Chain | undefined,\n  TAbi extends Abi | readonly unknown[] | undefined,\n  TEventName extends string | undefined,\n  TStrict extends boolean | undefined = undefined,\n  TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n  TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n>(\n  _client: Client<Transport, TChain>,\n  {\n    filter,\n  }: GetFilterLogsParameters<TAbi, TEventName, TStrict, TFromBlock, TToBlock>,\n): Promise<\n  GetFilterLogsReturnType<TAbi, TEventName, TStrict, TFromBlock, TToBlock>\n> {\n  const strict = filter.strict ?? false\n\n  const logs = await filter.request({\n    method: 'eth_getFilterLogs',\n    params: [filter.id],\n  })\n  return logs\n    .map((log) => {\n      try {\n        const { eventName, args } =\n          'abi' in filter && filter.abi\n            ? decodeEventLog({\n                abi: filter.abi,\n                data: log.data,\n                topics: log.topics as any,\n                strict,\n              })\n            : { eventName: undefined, args: undefined }\n        return formatLog(log, { args, eventName })\n      } catch (err) {\n        let eventName\n        let isUnnamed\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if ('strict' in filter && filter.strict) return\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return formatLog(log, { args: isUnnamed ? [] : {}, eventName })\n      }\n    })\n    .filter(Boolean) as unknown as GetFilterLogsReturnType<\n    TAbi,\n    TEventName,\n    TStrict,\n    TFromBlock,\n    TToBlock\n  >\n}\n", "import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type GetStorageAtParameters = {\n  address: Address\n  slot: Hex\n} & (\n  | {\n      blockNumber?: never\n      blockTag?: BlockTag\n    }\n  | {\n      blockNumber?: bigint\n      blockTag?: never\n    }\n)\n\nexport type GetStorageAtReturnType = Hex | undefined\n\n/**\n * Returns the value from a storage slot at a given address.\n *\n * - Docs: https://viem.sh/docs/contract/getStorageAt.html\n * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n *\n * @param client - Client to use\n * @param parameters - {@link GetStorageAtParameters}\n * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getStorageAt } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const code = await getStorageAt(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   slot: toHex(0),\n * })\n */\nexport async function getStorageAt<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { address, blockNumber, blockTag = 'latest', slot }: GetStorageAtParameters,\n): Promise<GetStorageAtReturnType> {\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n  const data = await client.request({\n    method: 'eth_getStorageAt',\n    params: [address, slot, blockNumberHex || blockTag],\n  })\n  return data\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { TransactionNotFoundError } from '../../errors/transaction.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { RpcTransaction } from '../../types/rpc.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\nimport {\n  type FormattedTransaction,\n  formatTransaction,\n} from '../../utils/formatters/transaction.js'\n\nexport type GetTransactionParameters<TBlockTag extends BlockTag = 'latest'> =\n  | {\n      /** The block hash */\n      blockHash: Hash\n      blockNumber?: never\n      blockTag?: never\n      hash?: never\n      /** The index of the transaction on the block. */\n      index: number\n    }\n  | {\n      blockHash?: never\n      /** The block number */\n      blockNumber: bigint\n      blockTag?: never\n      hash?: never\n      /** The index of the transaction on the block. */\n      index: number\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      /** The block tag. */\n      blockTag: TBlockTag | BlockTag\n      hash?: never\n      /** The index of the transaction on the block. */\n      index: number\n    }\n  | {\n      blockHash?: never\n      blockNumber?: never\n      blockTag?: never\n      /** The hash of the transaction. */\n      hash: Hash\n      index?: number\n    }\n\nexport type GetTransactionReturnType<\n  TChain extends Chain | undefined = Chain,\n  TBlockTag extends BlockTag = 'latest',\n> = FormattedTransaction<TChain, TBlockTag>\n\n/**\n * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransaction.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionParameters}\n * @returns The transaction information. {@link GetTransactionReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransaction } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transaction = await getTransaction(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransaction<\n  TChain extends Chain | undefined,\n  TBlockTag extends BlockTag = 'latest',\n>(\n  client: Client<Transport, TChain>,\n  {\n    blockHash,\n    blockNumber,\n    blockTag: blockTag_,\n    hash,\n    index,\n  }: GetTransactionParameters<TBlockTag>,\n): Promise<GetTransactionReturnType<TChain, TBlockTag>> {\n  const blockTag = blockTag_ || 'latest'\n\n  const blockNumberHex =\n    blockNumber !== undefined ? numberToHex(blockNumber) : undefined\n\n  let transaction: RpcTransaction | null = null\n  if (hash) {\n    transaction = await client.request({\n      method: 'eth_getTransactionByHash',\n      params: [hash],\n    })\n  } else if (blockHash) {\n    transaction = await client.request({\n      method: 'eth_getTransactionByBlockHashAndIndex',\n      params: [blockHash, numberToHex(index)],\n    })\n  } else if (blockNumberHex || blockTag) {\n    transaction = await client.request({\n      method: 'eth_getTransactionByBlockNumberAndIndex',\n      params: [blockNumberHex || blockTag, numberToHex(index)],\n    })\n  }\n\n  if (!transaction)\n    throw new TransactionNotFoundError({\n      blockHash,\n      blockNumber,\n      blockTag,\n      hash,\n      index,\n    })\n\n  const format =\n    client.chain?.formatters?.transaction?.format || formatTransaction\n  return format(transaction)\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { FormattedTransactionReceipt } from '../../utils/formatters/transactionReceipt.js'\n\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getTransaction } from './getTransaction.js'\n\nexport type GetTransactionConfirmationsParameters<\n  TChain extends Chain | undefined = Chain,\n> =\n  | {\n      /** The transaction hash. */\n      hash: Hash\n      transactionReceipt?: never\n    }\n  | {\n      hash?: never\n      /** The transaction receipt. */\n      transactionReceipt: FormattedTransactionReceipt<TChain>\n    }\n\nexport type GetTransactionConfirmationsReturnType = bigint\n\n/**\n * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionConfirmationsParameters}\n * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionConfirmations } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const confirmations = await getTransactionConfirmations(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionConfirmations<\n  TChain extends Chain | undefined,\n>(\n  client: Client<Transport, TChain>,\n  { hash, transactionReceipt }: GetTransactionConfirmationsParameters<TChain>,\n): Promise<GetTransactionConfirmationsReturnType> {\n  const [blockNumber, transaction] = await Promise.all([\n    getBlockNumber(client),\n    hash ? getTransaction(client, { hash }) : undefined,\n  ])\n  const transactionBlockNumber =\n    transactionReceipt?.blockNumber || transaction?.blockNumber\n  if (!transactionBlockNumber) return 0n\n  return blockNumber - transactionBlockNumber! + 1n\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { TransactionReceiptNotFoundError } from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport {\n  type FormattedTransactionReceipt,\n  formatTransactionReceipt,\n} from '../../utils/formatters/transactionReceipt.js'\n\nexport type GetTransactionReceiptParameters = {\n  /** The hash of the transaction. */\n  hash: Hash\n}\n\nexport type GetTransactionReceiptReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionReceipt<TChain>\n\n/**\n * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.\n *\n * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions\n * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)\n *\n * @param client - Client to use\n * @param parameters - {@link GetTransactionReceiptParameters}\n * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getTransactionReceipt } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await getTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function getTransactionReceipt<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { hash }: GetTransactionReceiptParameters,\n) {\n  const receipt = await client.request({\n    method: 'eth_getTransactionReceipt',\n    params: [hash],\n  })\n\n  if (!receipt) throw new TransactionReceiptNotFoundError({ hash })\n\n  const format =\n    client.chain?.formatters?.transactionReceipt?.format ||\n    formatTransactionReceipt\n  return format(receipt) as GetTransactionReceiptReturnType<TChain>\n}\n", "import type { Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ContractFunctionConfig } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  MulticallContracts,\n  MulticallResults,\n} from '../../types/multicall.js'\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataParameters,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { getChainContractAddress } from '../../utils/chain.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\n\nimport type { CallParameters } from './call.js'\nimport { readContract } from './readContract.js'\n\nexport type MulticallParameters<\n  TContracts extends ContractFunctionConfig[] = ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n> = Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n  allowFailure?: TAllowFailure\n  /** The maximum size (in bytes) for each calldata chunk. Set to `0` to disable the size limit. @default 1_024 */\n  batchSize?: number\n  contracts: Narrow<readonly [...MulticallContracts<TContracts>]>\n  multicallAddress?: Address\n}\n\nexport type MulticallReturnType<\n  TContracts extends ContractFunctionConfig[] = ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n> = MulticallResults<TContracts, TAllowFailure>\n\n/**\n * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n *\n * - Docs: https://viem.sh/docs/contract/multicall.html\n *\n * @param client - Client to use\n * @param parameters - {@link MulticallParameters}\n * @returns An array of results with accompanying status. {@link MulticallReturnType}\n *\n * @example\n * import { createPublicClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { multicall } from 'viem/contract'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const abi = parseAbi([\n *   'function balanceOf(address) view returns (uint256)',\n *   'function totalSupply() view returns (uint256)',\n * ])\n * const results = await multicall(client, {\n *   contracts: [\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'balanceOf',\n *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n *     },\n *     {\n *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *       abi,\n *       functionName: 'totalSupply',\n *     },\n *   ],\n * })\n * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n */\nexport async function multicall<\n  TChain extends Chain | undefined,\n  TContracts extends ContractFunctionConfig[],\n  TAllowFailure extends boolean = true,\n>(\n  client: Client<Transport, TChain>,\n  args: MulticallParameters<TContracts, TAllowFailure>,\n): Promise<MulticallReturnType<TContracts, TAllowFailure>> {\n  const {\n    allowFailure = true,\n    batchSize: batchSize_,\n    blockNumber,\n    blockTag,\n    contracts: contracts_,\n    multicallAddress: multicallAddress_,\n  } = args\n\n  const batchSize =\n    batchSize_ ??\n    ((typeof client.batch?.multicall === 'object' &&\n      client.batch.multicall.batchSize) ||\n      1_024)\n\n  // Fix type cast from `Narrow` in type definition.\n  const contracts = contracts_ as readonly [...MulticallContracts<TContracts>]\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. multicallAddress is required.',\n      )\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  type Aggregate3Calls = {\n    allowFailure: boolean\n    callData: Hex\n    target: Address\n  }[]\n\n  const chunkedCalls: Aggregate3Calls[] = [[]]\n  let currentChunk = 0\n  let currentChunkSize = 0\n  for (let i = 0; i < contracts.length; i++) {\n    const { abi, address, args, functionName } = contracts[i]\n    try {\n      const callData = encodeFunctionData({\n        abi,\n        args,\n        functionName,\n      } as unknown as EncodeFunctionDataParameters)\n\n      currentChunkSize += callData.length\n      if (batchSize > 0 && currentChunkSize > batchSize) {\n        currentChunk++\n        currentChunkSize = (callData.length - 2) / 2\n        chunkedCalls[currentChunk] = []\n      }\n\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData,\n          target: address,\n        },\n      ]\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      chunkedCalls[currentChunk] = [\n        ...chunkedCalls[currentChunk],\n        {\n          allowFailure: true,\n          callData: '0x' as Hex,\n          target: address,\n        },\n      ]\n    }\n  }\n\n  const results = await Promise.all(\n    chunkedCalls.map((calls) =>\n      readContract(client, {\n        abi: multicall3Abi,\n        address: multicallAddress!,\n        args: [calls],\n        blockNumber,\n        blockTag,\n        functionName: 'aggregate3',\n      }),\n    ),\n  )\n\n  return results.flat().map(({ returnData, success }, i) => {\n    const calls = chunkedCalls.flat()\n    const { callData } = calls[i]\n    const { abi, address, functionName, args } = contracts[i]\n    try {\n      if (callData === '0x') throw new AbiDecodingZeroDataError()\n      if (!success) throw new RawContractError({ data: returnData })\n      const result = decodeFunctionResult({\n        abi,\n        args,\n        data: returnData,\n        functionName: functionName,\n      })\n      return allowFailure ? { result, status: 'success' } : result\n    } catch (err) {\n      const error = getContractError(err as BaseError, {\n        abi,\n        address,\n        args,\n        docsPath: '/docs/contract/multicall',\n        functionName,\n      })\n      if (!allowFailure) throw error\n      return { error, result: undefined, status: 'failure' }\n    }\n  }) as MulticallResults<TContracts, TAllowFailure>\n}\n", "export const universalSignatureValidatorByteCode =\n  '0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572'\n", "import { type ByteArray, type Hex, isHex, toBytes } from '../../index.js'\nimport { equalBytes } from '@noble/curves/abstract/utils'\n\nexport function isBytesEqual(a_: ByteArray | Hex, b_: ByteArray | Hex) {\n  const a = isHex(a_) ? toBytes(a_) : a_\n  const b = isHex(b_) ? toBytes(b_) : b_\n  return equalBytes(a, b)\n}\n", "import type { Address } from 'abitype'\n\nimport type { Chain } from '../../chains/index.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalSignatureValidatorAbi } from '../../constants/abis.js'\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { isBytesEqual } from '../../utils/data/isBytesEqual.js'\nimport { encodeDeployData, isHex, toHex } from '../../utils/index.js'\nimport { type CallParameters, call } from './call.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The hash to be verified. */\n  hash: Hex\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray\n}\n\nexport type VerifyHashReturnType = boolean\n\n/**\n * Verifies a message hash on chain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  { address, hash, signature, ...callRequest }: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const signatureHex = isHex(signature) ? signature : toHex(signature)\n\n  try {\n    const { data } = await call(client, {\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, signatureHex],\n        bytecode: universalSignatureValidatorByteCode,\n      }),\n      ...callRequest,\n    } as unknown as CallParameters)\n\n    return isBytesEqual(data ?? '0x0', '0x1')\n  } catch (error) {\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n", "import type { Chain } from '../../chains/index.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { hashMessage } from '../../utils/index.js'\nimport { type VerifyHashParameters, verifyHash } from './verifyHash.js'\nimport type { Address } from 'abitype'\n\nexport type VerifyMessageParameters = Omit<VerifyHashParameters, 'hash'> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The message to be verified. */\n  message: SignableMessage\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray\n}\n\nexport type VerifyMessageReturnType = boolean\n\n/**\n * Verify that a message was signed by the provided address.\n *\n * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage.html}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyMessageParameters}\n * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}\n */\nexport async function verifyMessage<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  { address, message, signature, ...callRequest }: VerifyMessageParameters,\n): Promise<VerifyMessageReturnType> {\n  const hash = hashMessage(message)\n  return verifyHash(client, {\n    address,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n", "import type { Chain } from '../../chains/index.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { hashTypedData } from '../../utils/signature/hashTypedData.js'\nimport { type VerifyHashParameters, verifyHash } from './verifyHash.js'\nimport type { Address, TypedData } from 'abitype'\n\nexport type VerifyTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n> = Omit<VerifyHashParameters, 'hash'> &\n  TypedDataDefinition<TTypedData, TPrimaryType> & {\n    /** The address to verify the typed data for. */\n    address: Address\n    /** The signature to verify */\n    signature: Hex | ByteArray\n  }\n\nexport type VerifyTypedDataReturnType = boolean\n\n/**\n * Verify that typed data was signed by the provided address.\n *\n * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData.html}\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyTypedDataParameters}\n * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}\n */\nexport async function verifyTypedData<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    signature,\n    message,\n    primaryType,\n    types,\n    domain,\n    ...callRequest\n  }: VerifyTypedDataParameters,\n): Promise<VerifyTypedDataReturnType> {\n  const hash = hashTypedData({ message, primaryType, types, domain })\n  return verifyHash(client, {\n    address,\n    hash,\n    signature,\n    ...callRequest,\n  })\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport { hexToBigInt } from '../../utils/encoding/fromHex.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from './getBlockNumber.js'\n\nexport type OnBlockNumberParameter = GetBlockNumberReturnType\nexport type OnBlockNumberFn = (\n  blockNumber: OnBlockNumberParameter,\n  prevBlockNumber: OnBlockNumberParameter | undefined,\n) => void\n\nexport type PollOptions = {\n  /** Whether or not to emit the missed block numbers to the callback. */\n  emitMissed?: boolean\n  /** Whether or not to emit the latest block number to the callback when the subscription opens. */\n  emitOnBegin?: boolean\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n}\n\nexport type WatchBlockNumberParameters<\n  TTransport extends Transport = Transport,\n> = {\n  /** The callback to call when a new block number is received. */\n  onBlockNumber: OnBlockNumberFn\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n} & (GetTransportConfig<TTransport>['type'] extends 'webSocket'\n  ?\n      | {\n          emitMissed?: never\n          emitOnBegin?: never\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions & { poll: true })\n  : PollOptions & { poll?: true })\n\nexport type WatchBlockNumberReturnType = () => void\n\n/**\n * Watches and returns incoming block numbers.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlockNumberParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n *\n * @example\n * import { createPublicClient, watchBlockNumber, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlockNumber(client, {\n *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n * })\n */\nexport function watchBlockNumber<\n  TChain extends Chain | undefined,\n  TTransport extends Transport,\n>(\n  client: Client<TTransport, TChain>,\n  {\n    emitOnBegin = false,\n    emitMissed = false,\n    onBlockNumber,\n    onError,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlockNumberParameters<TTransport>,\n): WatchBlockNumberReturnType {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n\n  let prevBlockNumber: GetBlockNumberReturnType | undefined\n\n  const pollBlockNumber = () => {\n    const observerId = stringify([\n      'watchBlockNumber',\n      client.uid,\n      emitOnBegin,\n      emitMissed,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlockNumber, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const blockNumber = await getBlockNumber(client, { cacheTime: 0 })\n\n            if (prevBlockNumber) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (blockNumber === prevBlockNumber) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (blockNumber - prevBlockNumber > 1 && emitMissed) {\n                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\n                  emit.onBlockNumber(i, prevBlockNumber)\n                  prevBlockNumber = i\n                }\n              }\n            }\n\n            // If the next block number is greater than the previous,\n            // it is not in the past, and we can emit the new block number.\n            if (!prevBlockNumber || blockNumber > prevBlockNumber) {\n              emit.onBlockNumber(blockNumber, prevBlockNumber)\n              prevBlockNumber = blockNumber\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlockNumber = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newHeads'],\n          onData(data: any) {\n            if (!active) return\n            const blockNumber = hexToBigInt(data.result?.number)\n            onBlockNumber(blockNumber, prevBlockNumber)\n            prevBlockNumber = blockNumber\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling ? pollBlockNumber() : subscribeBlockNumber()\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n} from '../../errors/transaction.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { observe } from '../../utils/observe.js'\nimport { withRetry } from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { getBlock } from './getBlock.js'\nimport {\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport { watchBlockNumber } from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<TChain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<TChain>\n\nexport type WaitForTransactionReceiptParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: (response: ReplacementReturnType<TChain>) => void\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n  /** Optional timeout (in milliseconds) to wait before stopping polling. */\n  timeout?: number\n}\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html\n * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  TChain extends Chain | undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    timeout,\n  }: WaitForTransactionReceiptParameters<TChain>,\n): Promise<WaitForTransactionReceiptReturnType<TChain>> {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  let transaction: GetTransactionReturnType<TChain> | undefined\n  let replacedTransaction: GetTransactionReturnType<TChain> | undefined\n  let receipt: GetTransactionReceiptReturnType<TChain>\n  let retrying = false\n\n  return new Promise((resolve, reject) => {\n    if (timeout)\n      setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n\n    const _unobserve = observe(\n      observerId,\n      { onReplaced, resolve, reject },\n      (emit) => {\n        const _unwatch = watchBlockNumber(client, {\n          emitMissed: true,\n          emitOnBegin: true,\n          poll: true,\n          pollingInterval,\n          async onBlockNumber(blockNumber_) {\n            if (retrying) return\n\n            let blockNumber = blockNumber_\n\n            const done = (fn: () => void) => {\n              _unwatch()\n              fn()\n              _unobserve()\n            }\n\n            try {\n              // If we already have a valid receipt, let's check if we have enough\n              // confirmations. If we do, then we can resolve.\n              if (receipt) {\n                if (blockNumber - receipt.blockNumber + 1n < confirmations)\n                  return\n\n                done(() => emit.resolve(receipt))\n                return\n              }\n\n              // Get the transaction to check if it's been replaced.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined transactions.\n              if (!transaction) {\n                retrying = true\n                await withRetry(\n                  async () => {\n                    transaction = await getTransaction(client, { hash })\n                    if (transaction.blockNumber)\n                      blockNumber = transaction.blockNumber\n                  },\n                  {\n                    // exponential backoff\n                    delay: ({ count }) => ~~(1 << count) * 200,\n                    retryCount: 6,\n                  },\n                )\n                retrying = false\n              }\n\n              // Get the receipt to check if it's been processed.\n              receipt = await getTransactionReceipt(client, { hash })\n\n              // Check if we have enough confirmations. If not, continue polling.\n              if (\n                confirmations > 0 &&\n                blockNumber - receipt.blockNumber + 1n < confirmations\n              )\n                return\n\n              done(() => emit.resolve(receipt))\n            } catch (err) {\n              // If the receipt is not found, the transaction will be pending.\n              // We need to check if it has potentially been replaced.\n              if (\n                transaction &&\n                (err instanceof TransactionNotFoundError ||\n                  err instanceof TransactionReceiptNotFoundError)\n              ) {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                const block = await getBlock(client, {\n                  blockNumber,\n                  includeTransactions: true,\n                })\n\n                const replacementTransaction = (\n                  block.transactions as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getTransactionReceipt(client, {\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (blockNumber - receipt.blockNumber + 1n < confirmations)\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction!,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt,\n                  })\n                  emit.resolve(receipt)\n                })\n              } else {\n                done(() => emit.reject(err))\n              }\n            }\n          },\n        })\n      },\n    )\n  })\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport { formatBlock } from '../../utils/formatters/block.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockReturnType, getBlock } from './getBlock.js'\n\nexport type OnBlockParameter<\n  TChain extends Chain | undefined = Chain,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = GetBlockReturnType<TChain, TIncludeTransactions, TBlockTag>\n\nexport type OnBlock<\n  TChain extends Chain | undefined = Chain,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = (\n  block: OnBlockParameter<TChain, TIncludeTransactions, TBlockTag>,\n  prevBlock:\n    | OnBlockParameter<TChain, TIncludeTransactions, TBlockTag>\n    | undefined,\n) => void\n\ntype PollOptions<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = {\n  /** The block tag. Defaults to \"latest\". */\n  blockTag?: TBlockTag | BlockTag\n  /** Whether or not to emit the missed blocks to the callback. */\n  emitMissed?: boolean\n  /** Whether or not to emit the block to the callback when the subscription opens. */\n  emitOnBegin?: boolean\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions\n  /** Polling frequency (in ms). Defaults to the client's pollingInterval config. */\n  pollingInterval?: number\n}\n\nexport type WatchBlocksParameters<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n> = {\n  /** The callback to call when a new block is received. */\n  onBlock: OnBlock<TChain, TIncludeTransactions, TBlockTag>\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n} & (GetTransportConfig<TTransport>['type'] extends 'webSocket'\n  ?\n      | {\n          blockTag?: never\n          emitMissed?: never\n          emitOnBegin?: never\n          includeTransactions?: never\n          /** Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`. */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions<TIncludeTransactions, TBlockTag> & { poll?: true })\n  : PollOptions<TIncludeTransactions, TBlockTag> & { poll?: true })\n\nexport type WatchBlocksReturnType = () => void\n\n/**\n * Watches and returns information for incoming blocks.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchBlocks.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n * - JSON-RPC Methods:\n *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchBlocksParameters}\n * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n *\n * @example\n * import { createPublicClient, watchBlocks, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchBlocks(client, {\n *   onBlock: (block) => console.log(block),\n * })\n */\nexport function watchBlocks<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = 'latest',\n>(\n  client: Client<TTransport, TChain>,\n  {\n    blockTag = 'latest',\n    emitMissed = false,\n    emitOnBegin = false,\n    onBlock,\n    onError,\n    includeTransactions: includeTransactions_,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchBlocksParameters<TTransport, TChain, TIncludeTransactions, TBlockTag>,\n): WatchBlocksReturnType {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n  const includeTransactions = includeTransactions_ ?? false\n\n  let prevBlock:\n    | GetBlockReturnType<TChain, false | TIncludeTransactions, 'latest'>\n    | undefined\n\n  const pollBlocks = () => {\n    const observerId = stringify([\n      'watchBlocks',\n      client.uid,\n      emitMissed,\n      emitOnBegin,\n      includeTransactions,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onBlock, onError }, (emit) =>\n      poll(\n        async () => {\n          try {\n            const block = await getBlock(client, {\n              blockTag,\n              includeTransactions,\n            })\n            if (block.number && prevBlock?.number) {\n              // If the current block number is the same as the previous,\n              // we can skip.\n              if (block.number === prevBlock.number) return\n\n              // If we have missed out on some previous blocks, and the\n              // `emitMissed` flag is truthy, let's emit those blocks.\n              if (block.number - prevBlock.number > 1 && emitMissed) {\n                for (let i = prevBlock?.number + 1n; i < block.number; i++) {\n                  const block = await getBlock(client, {\n                    blockNumber: i,\n                    includeTransactions,\n                  })\n                  emit.onBlock(block as any, prevBlock as any)\n                  prevBlock = block\n                }\n              }\n            }\n\n            if (\n              // If no previous block exists, emit.\n              !prevBlock?.number ||\n              // If the block tag is \"pending\" with no block number, emit.\n              (blockTag === 'pending' && !block?.number) ||\n              // If the next block number is greater than the previous block number, emit.\n              // We don't want to emit blocks in the past.\n              (block.number && block.number > prevBlock.number)\n            ) {\n              emit.onBlock(block as any, prevBlock as any)\n              prevBlock = block as any\n            }\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin,\n          interval: pollingInterval,\n        },\n      ),\n    )\n  }\n\n  const subscribeBlocks = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newHeads'],\n          onData(data: any) {\n            if (!active) return\n            const format =\n              client.chain?.formatters?.block?.format || formatBlock\n            const block = format(data.result)\n            onBlock(block, prevBlock as any)\n            prevBlock = block\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling ? pollBlocks() : subscribeBlocks()\n}\n", "import type { AbiEvent, Address, Narrow } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport {\n  type CreateEventFilterParameters,\n  createEventFilter,\n} from './createEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { type GetLogsParameters, getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type WatchEventOnLogsParameter<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = Log<bigint, number, false, TAbiEvent, TStrict, TAbiEvents, TEventName>[]\nexport type WatchEventOnLogsFn<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = (\n  logs: WatchEventOnLogsParameter<TAbiEvent, TAbiEvents, TStrict, _EventName>,\n) => void\n\nexport type WatchEventParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /**\n   * Whether or not the event logs should be batched on each invocation.\n   * @default true\n   */\n  batch?: boolean\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchEventOnLogsFn<TAbiEvent, TAbiEvents, TStrict, _EventName>\n  /** Polling frequency (in ms). Defaults to Client's pollingInterval config. */\n  pollingInterval?: number\n} & (\n  | {\n      event: Narrow<TAbiEvent>\n      events?: never\n      args?: MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: TStrict\n    }\n  | {\n      event?: never\n      events?: Narrow<TAbiEvents>\n      args?: never\n      /**\n       * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n       * @default false\n       */\n      strict?: TStrict\n    }\n  | {\n      event?: never\n      events?: never\n      args?: never\n      strict?: never\n    }\n)\n\nexport type WatchEventReturnType = () => void\n\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent.html\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent<\n  TChain extends Chain | undefined,\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    args,\n    batch = true,\n    event,\n    events,\n    onError,\n    onLogs,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchEventParameters<TAbiEvent, TAbiEvents, TStrict>,\n): WatchEventReturnType {\n  const observerId = stringify([\n    'watchEvent',\n    address,\n    args,\n    batch,\n    client.uid,\n    event,\n    pollingInterval,\n  ])\n  const strict = strict_ ?? false\n\n  return observe(observerId, { onLogs, onError }, (emit) => {\n    let previousBlockNumber: bigint\n    let filter: Filter<'event', TAbiEvents, _EventName, any>\n    let initialized = false\n\n    const unwatch = poll(\n      async () => {\n        if (!initialized) {\n          try {\n            filter = (await createEventFilter(client, {\n              address,\n              args,\n              event: event!,\n              events,\n              strict,\n            } as unknown as CreateEventFilterParameters)) as unknown as Filter<\n              'event',\n              TAbiEvents,\n              _EventName\n            >\n          } catch {}\n          initialized = true\n          return\n        }\n\n        try {\n          let logs: Log[]\n          if (filter) {\n            logs = await getFilterChanges(client, { filter })\n          } else {\n            // If the filter doesn't exist, we will fall back to use `getLogs`.\n            // The fall back exists because some RPC Providers do not support filters.\n\n            // Fetch the block number to use for `getLogs`.\n            const blockNumber = await getBlockNumber(client)\n\n            // If the block number has changed, we will need to fetch the logs.\n            // If the block number doesn't exist, we are yet to reach the first poll interval,\n            // so do not emit any logs.\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await getLogs(client, {\n                address,\n                args,\n                event: event!,\n                events,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber,\n              } as unknown as GetLogsParameters)\n            } else {\n              logs = []\n            }\n            previousBlockNumber = blockNumber\n          }\n\n          if (logs.length === 0) return\n          if (batch) emit.onLogs(logs as any)\n          else logs.forEach((log) => emit.onLogs([log] as any))\n        } catch (err) {\n          emit.onError?.(err as Error)\n        }\n      },\n      {\n        emitOnBegin: true,\n        interval: pollingInterval,\n      },\n    )\n\n    return async () => {\n      if (filter) await uninstallFilter(client, { filter })\n      unwatch()\n    }\n  })\n}\n", "import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport { observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { createPendingTransactionFilter } from './createPendingTransactionFilter.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\nexport type OnTransactionsParameter = Hash[]\nexport type OnTransactionsFn = (transactions: OnTransactionsParameter) => void\n\ntype PollOptions = {\n  /**\n   * Whether or not the transaction hashes should be batched on each invocation.\n   * @default true\n   */\n  batch?: boolean\n  /**\n   * Polling frequency (in ms). Defaults to Client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n}\n\nexport type WatchPendingTransactionsParameters<\n  TTransport extends Transport = Transport,\n> = {\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new transactions are received. */\n  onTransactions: OnTransactionsFn\n} & (GetTransportConfig<TTransport>['type'] extends 'webSocket'\n  ?\n      | {\n          batch?: never\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default false\n           */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions & {\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default true\n           */\n          poll?: true\n        })\n  : PollOptions & {\n      poll?: true\n    })\n\nexport type WatchPendingTransactionsReturnType = () => void\n\n/**\n * Watches and returns pending transaction hashes.\n *\n * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html\n * - JSON-RPC Methods:\n *   - When `poll: true`\n *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n *\n * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions).\n *\n * @param client - Client to use\n * @param parameters - {@link WatchPendingTransactionsParameters}\n * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchPendingTransactions } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = await watchPendingTransactions(client, {\n *   onTransactions: (hashes) => console.log(hashes),\n * })\n */\nexport function watchPendingTransactions<\n  TTransport extends Transport,\n  TChain extends Chain | undefined,\n>(\n  client: Client<TTransport, TChain>,\n  {\n    batch = true,\n    onError,\n    onTransactions,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n  }: WatchPendingTransactionsParameters<TTransport>,\n) {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n\n  const pollPendingTransactions = () => {\n    const observerId = stringify([\n      'watchPendingTransactions',\n      client.uid,\n      batch,\n      pollingInterval,\n    ])\n    return observe(observerId, { onTransactions, onError }, (emit) => {\n      let filter: Filter<'transaction'>\n\n      const unwatch = poll(\n        async () => {\n          try {\n            if (!filter) {\n              try {\n                filter = await createPendingTransactionFilter(client)\n                return\n              } catch (err) {\n                unwatch()\n                throw err\n              }\n            }\n\n            const hashes = await getFilterChanges(client, { filter })\n            if (hashes.length === 0) return\n            if (batch) emit.onTransactions(hashes)\n            else hashes.forEach((hash) => emit.onTransactions([hash]))\n          } catch (err) {\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter) await uninstallFilter(client, { filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribePendingTransactions = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['newPendingTransactions'],\n          onData(data: any) {\n            if (!active) return\n            const transaction = data.result\n            onTransactions([transaction])\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling\n    ? pollPendingTransactions()\n    : subscribePendingTransactions()\n}\n", "import type { Abi, AbiEvent } from 'abitype'\n\nimport {\n  type GetEnsAddressParameters,\n  type GetEnsAddressReturnType,\n  getEnsAddress,\n} from '../../actions/ens/getEnsAddress.js'\nimport {\n  type GetEnsAvatarParameters,\n  type GetEnsAvatarReturnType,\n  getEnsAvatar,\n} from '../../actions/ens/getEnsAvatar.js'\nimport {\n  type GetEnsNameParameters,\n  type GetEnsNameReturnType,\n  getEnsName,\n} from '../../actions/ens/getEnsName.js'\nimport {\n  type GetEnsResolverParameters,\n  type GetEnsResolverReturnType,\n  getEnsResolver,\n} from '../../actions/ens/getEnsResolver.js'\nimport {\n  type GetEnsTextParameters,\n  type GetEnsTextReturnType,\n  getEnsText,\n} from '../../actions/ens/getEnsText.js'\nimport {\n  type CallParameters,\n  type CallReturnType,\n  call,\n} from '../../actions/public/call.js'\nimport {\n  type CreateBlockFilterReturnType,\n  createBlockFilter,\n} from '../../actions/public/createBlockFilter.js'\nimport {\n  type CreateContractEventFilterParameters,\n  type CreateContractEventFilterReturnType,\n  createContractEventFilter,\n} from '../../actions/public/createContractEventFilter.js'\nimport {\n  type CreateEventFilterParameters,\n  type CreateEventFilterReturnType,\n  createEventFilter,\n} from '../../actions/public/createEventFilter.js'\nimport {\n  type CreatePendingTransactionFilterReturnType,\n  createPendingTransactionFilter,\n} from '../../actions/public/createPendingTransactionFilter.js'\nimport {\n  type EstimateContractGasParameters,\n  type EstimateContractGasReturnType,\n  estimateContractGas,\n} from '../../actions/public/estimateContractGas.js'\nimport {\n  type EstimateGasParameters,\n  type EstimateGasReturnType,\n  estimateGas,\n} from '../../actions/public/estimateGas.js'\nimport {\n  type GetBalanceParameters,\n  type GetBalanceReturnType,\n  getBalance,\n} from '../../actions/public/getBalance.js'\nimport {\n  type GetBlockParameters,\n  type GetBlockReturnType,\n  getBlock,\n} from '../../actions/public/getBlock.js'\nimport {\n  type GetBlockNumberParameters,\n  type GetBlockNumberReturnType,\n  getBlockNumber,\n} from '../../actions/public/getBlockNumber.js'\nimport {\n  type GetBlockTransactionCountParameters,\n  type GetBlockTransactionCountReturnType,\n  getBlockTransactionCount,\n} from '../../actions/public/getBlockTransactionCount.js'\nimport {\n  type GetBytecodeParameters,\n  type GetBytecodeReturnType,\n  getBytecode,\n} from '../../actions/public/getBytecode.js'\nimport {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../actions/public/getChainId.js'\nimport {\n  type GetFeeHistoryParameters,\n  type GetFeeHistoryReturnType,\n  getFeeHistory,\n} from '../../actions/public/getFeeHistory.js'\nimport {\n  type GetFilterChangesParameters,\n  type GetFilterChangesReturnType,\n  getFilterChanges,\n} from '../../actions/public/getFilterChanges.js'\nimport {\n  type GetFilterLogsParameters,\n  type GetFilterLogsReturnType,\n  getFilterLogs,\n} from '../../actions/public/getFilterLogs.js'\nimport {\n  type GetGasPriceReturnType,\n  getGasPrice,\n} from '../../actions/public/getGasPrice.js'\nimport {\n  type GetLogsParameters,\n  type GetLogsReturnType,\n  getLogs,\n} from '../../actions/public/getLogs.js'\nimport {\n  type GetStorageAtParameters,\n  type GetStorageAtReturnType,\n  getStorageAt,\n} from '../../actions/public/getStorageAt.js'\nimport {\n  type GetTransactionParameters,\n  type GetTransactionReturnType,\n  getTransaction,\n} from '../../actions/public/getTransaction.js'\nimport {\n  type GetTransactionConfirmationsParameters,\n  type GetTransactionConfirmationsReturnType,\n  getTransactionConfirmations,\n} from '../../actions/public/getTransactionConfirmations.js'\nimport {\n  type GetTransactionCountParameters,\n  type GetTransactionCountReturnType,\n  getTransactionCount,\n} from '../../actions/public/getTransactionCount.js'\nimport {\n  type GetTransactionReceiptParameters,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from '../../actions/public/getTransactionReceipt.js'\nimport {\n  type MulticallParameters,\n  type MulticallReturnType,\n  multicall,\n} from '../../actions/public/multicall.js'\nimport {\n  type ReadContractParameters,\n  type ReadContractReturnType,\n  readContract,\n} from '../../actions/public/readContract.js'\nimport {\n  type SimulateContractParameters,\n  type SimulateContractReturnType,\n  simulateContract,\n} from '../../actions/public/simulateContract.js'\nimport {\n  type UninstallFilterParameters,\n  type UninstallFilterReturnType,\n  uninstallFilter,\n} from '../../actions/public/uninstallFilter.js'\nimport {\n  type VerifyMessageParameters,\n  type VerifyMessageReturnType,\n  verifyMessage,\n} from '../../actions/public/verifyMessage.js'\nimport {\n  type VerifyTypedDataParameters,\n  type VerifyTypedDataReturnType,\n  verifyTypedData,\n} from '../../actions/public/verifyTypedData.js'\nimport {\n  type WaitForTransactionReceiptParameters,\n  type WaitForTransactionReceiptReturnType,\n  waitForTransactionReceipt,\n} from '../../actions/public/waitForTransactionReceipt.js'\nimport {\n  type WatchBlockNumberParameters,\n  type WatchBlockNumberReturnType,\n  watchBlockNumber,\n} from '../../actions/public/watchBlockNumber.js'\nimport {\n  type WatchBlocksParameters,\n  type WatchBlocksReturnType,\n  watchBlocks,\n} from '../../actions/public/watchBlocks.js'\nimport {\n  type WatchContractEventParameters,\n  type WatchContractEventReturnType,\n  watchContractEvent,\n} from '../../actions/public/watchContractEvent.js'\nimport {\n  type WatchEventParameters,\n  type WatchEventReturnType,\n  watchEvent,\n} from '../../actions/public/watchEvent.js'\nimport {\n  type WatchPendingTransactionsParameters,\n  type WatchPendingTransactionsReturnType,\n  watchPendingTransactions,\n} from '../../actions/public/watchPendingTransactions.js'\nimport type { Account } from '../../types/account.js'\nimport type { BlockNumber, BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  ContractFunctionConfig,\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { FilterType } from '../../types/filter.js'\nimport type { Client } from '../createClient.js'\nimport type { Transport } from '../transports/createTransport.js'\n\nexport type PublicActions<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Executes a new message call immediately without submitting a transaction to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/call.html\n   * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n   *\n   * @param args - {@link CallParameters}\n   * @returns The call data. {@link CallReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const data = await client.call({\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   * })\n   */\n  call: (parameters: CallParameters<TChain>) => Promise<CallReturnType>\n  /**\n   * Creates a Filter to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createBlockFilter.html\n   * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)\n   *\n   * @returns Filter. {@link CreateBlockFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, createBlockFilter, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await createBlockFilter(client)\n   * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'block' }\n   */\n  createBlockFilter: () => Promise<CreateBlockFilterReturnType>\n  /**\n   * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs.html).\n   *\n   * - Docs: https://viem.sh/docs/contract/createContractEventFilter.html\n   *\n   * @param args - {@link CreateContractEventFilterParameters}\n   * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateContractEventFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createContractEventFilter({\n   *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n   * })\n   */\n  createContractEventFilter: <\n    TAbi extends Abi | readonly unknown[],\n    TEventName extends string | undefined,\n    TArgs extends MaybeExtractEventArgsFromAbi<TAbi, TEventName> | undefined,\n    TStrict extends boolean | undefined = undefined,\n    TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: CreateContractEventFilterParameters<\n      TAbi,\n      TEventName,\n      TArgs,\n      TStrict,\n      TFromBlock,\n      TToBlock\n    >,\n  ) => Promise<\n    CreateContractEventFilterReturnType<\n      TAbi,\n      TEventName,\n      TArgs,\n      TStrict,\n      TFromBlock,\n      TToBlock\n    >\n  >\n  /**\n   * Creates a [`Filter`](https://viem.sh/docs/glossary/types.html#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createEventFilter.html\n   * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)\n   *\n   * @param args - {@link CreateEventFilterParameters}\n   * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateEventFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createEventFilter({\n   *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n   * })\n   */\n  createEventFilter: <\n    TAbiEvent extends AbiEvent | undefined = undefined,\n    TAbiEvents extends\n      | readonly AbiEvent[]\n      | readonly unknown[]\n      | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n    TStrict extends boolean | undefined = undefined,\n    TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n    _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n    _Args extends\n      | MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n      | undefined = undefined,\n  >(\n    args?: CreateEventFilterParameters<\n      TAbiEvent,\n      TAbiEvents,\n      TStrict,\n      TFromBlock,\n      TToBlock,\n      _EventName,\n      _Args\n    >,\n  ) => Promise<\n    CreateEventFilterReturnType<\n      TAbiEvent,\n      TAbiEvents,\n      TStrict,\n      TFromBlock,\n      TToBlock,\n      _EventName,\n      _Args\n    >\n  >\n  /**\n   * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges.html).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter.html\n   * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)\n   *\n   * @returns [`Filter`](https://viem.sh/docs/glossary/types.html#filter). {@link CreateBlockFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createPendingTransactionFilter()\n   * // { id: \"0x345a6572337856574a76364e457a4366\", type: 'transaction' }\n   */\n  createPendingTransactionFilter: () => Promise<CreatePendingTransactionFilterReturnType>\n  /**\n   * Estimates the gas required to successfully execute a contract write function call.\n   *\n   * - Docs: https://viem.sh/docs/contract/estimateContractGas.html\n   *\n   * @remarks\n   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n   *\n   * @param args - {@link EstimateContractGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const gas = await client.estimateContractGas({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint() public']),\n   *   functionName: 'mint',\n   *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n   * })\n   */\n  estimateContractGas: <\n    TChain extends Chain | undefined,\n    TAbi extends Abi | readonly unknown[],\n    TFunctionName extends string,\n  >(\n    args: EstimateContractGasParameters<TAbi, TFunctionName, TChain, TAccount>,\n  ) => Promise<EstimateContractGasReturnType>\n  /**\n   * Estimates the gas necessary to complete a transaction without submitting it to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/estimateGas.html\n   * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)\n   *\n   * @param args - {@link EstimateGasParameters}\n   * @returns The gas estimate (in wei). {@link EstimateGasReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseEther } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const gasEstimate = await client.estimateGas({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: parseEther('1'),\n   * })\n   */\n  estimateGas: (\n    args: EstimateGasParameters<TChain, TAccount>,\n  ) => Promise<EstimateGasReturnType>\n  /**\n   * Returns the balance of an address in wei.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBalance.html\n   * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)\n   *\n   * @remarks\n   * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther.html).\n   *\n   * ```ts\n   * const balance = await getBalance(client, {\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   blockTag: 'safe'\n   * })\n   * const balanceAsEther = formatEther(balance)\n   * // \"6.942\"\n   * ```\n   *\n   * @param args - {@link GetBalanceParameters}\n   * @returns The balance of the address in wei. {@link GetBalanceReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const balance = await client.getBalance({\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   * // 10000000000000000000000n (wei)\n   */\n  getBalance: (args: GetBalanceParameters) => Promise<GetBalanceReturnType>\n  /**\n   * Returns information about a block at a block number, hash, or tag.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlock.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks\n   * - JSON-RPC Methods:\n   *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.\n   *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.\n   *\n   * @param args - {@link GetBlockParameters}\n   * @returns Information about the block. {@link GetBlockReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const block = await client.getBlock()\n   */\n  getBlock: <\n    TIncludeTransactions extends boolean = false,\n    TBlockTag extends BlockTag = 'latest',\n  >(\n    args?: GetBlockParameters<TIncludeTransactions, TBlockTag>,\n  ) => Promise<GetBlockReturnType<TChain, TIncludeTransactions, TBlockTag>>\n  /**\n   * Returns the number of the most recent block seen.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlockNumber.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/fetching-blocks\n   * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)\n   *\n   * @param args - {@link GetBlockNumberParameters}\n   * @returns The number of the block. {@link GetBlockNumberReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const blockNumber = await client.getBlockNumber()\n   * // 69420n\n   */\n  getBlockNumber: (\n    args?: GetBlockNumberParameters,\n  ) => Promise<GetBlockNumberReturnType>\n  /**\n   * Returns the number of Transactions at a block number, hash, or tag.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount.html\n   * - JSON-RPC Methods:\n   *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.\n   *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.\n   *\n   * @param args - {@link GetBlockTransactionCountParameters}\n   * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const count = await client.getBlockTransactionCount()\n   */\n  getBlockTransactionCount: (\n    args?: GetBlockTransactionCountParameters,\n  ) => Promise<GetBlockTransactionCountReturnType>\n  /**\n   * Retrieves the bytecode at an address.\n   *\n   * - Docs: https://viem.sh/docs/contract/getBytecode.html\n   * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)\n   *\n   * @param args - {@link GetBytecodeParameters}\n   * @returns The contract's bytecode. {@link GetBytecodeReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const code = await client.getBytecode({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   * })\n   */\n  getBytecode: (args: GetBytecodeParameters) => Promise<GetBytecodeReturnType>\n  /**\n   * Returns the chain ID associated with the current network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId.html\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Gets address for ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n   *\n   * @param args - {@link GetEnsAddressParameters}\n   * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const ensAddress = await client.getEnsAddress({\n   *   name: normalize('wagmi-dev.eth'),\n   * })\n   * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'\n   */\n  getEnsAddress: (\n    args: GetEnsAddressParameters,\n  ) => Promise<GetEnsAddressReturnType>\n  /**\n   * Gets the avatar of an ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText.html) with `key` set to `'avatar'`.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n   *\n   * @param args - {@link GetEnsAvatarParameters}\n   * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const ensAvatar = await client.getEnsAvatar({\n   *   name: normalize('wagmi-dev.eth'),\n   * })\n   * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'\n   */\n  getEnsAvatar: (\n    args: GetEnsAvatarParameters,\n  ) => Promise<GetEnsAvatarReturnType>\n  /**\n   * Gets primary name for specified address.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsName.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `reverse(bytes)` on ENS Universal Resolver Contract to \"reverse resolve\" the address to the primary ENS name.\n   *\n   * @param args - {@link GetEnsNameParameters}\n   * @returns Name or `null` if not found. {@link GetEnsNameReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const ensName = await client.getEnsName({\n   *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',\n   * })\n   * // 'wagmi-dev.eth'\n   */\n  getEnsName: (args: GetEnsNameParameters) => Promise<GetEnsNameReturnType>\n  /**\n   * Gets resolver for ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n   *\n   * @param args - {@link GetEnsResolverParameters}\n   * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const resolverAddress = await client.getEnsResolver({\n   *   name: normalize('wagmi-dev.eth'),\n   * })\n   * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'\n   */\n  getEnsResolver: (\n    args: GetEnsResolverParameters,\n  ) => Promise<GetEnsResolverReturnType>\n  /**\n   * Gets a text record for specified ENS name.\n   *\n   * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/ens\n   *\n   * @remarks\n   * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n   *\n   * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n   *\n   * @param args - {@link GetEnsTextParameters}\n   * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { normalize } from 'viem/ens'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const twitterRecord = await client.getEnsText({\n   *   name: normalize('wagmi-dev.eth'),\n   *   key: 'com.twitter',\n   * })\n   * // 'wagmi_sh'\n   */\n  getEnsText: (args: GetEnsTextParameters) => Promise<GetEnsTextReturnType>\n  /**\n   * Returns a collection of historical gas information.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getFeeHistory.html\n   * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)\n   *\n   * @param args - {@link GetFeeHistoryParameters}\n   * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const feeHistory = await client.getFeeHistory({\n   *   blockCount: 4,\n   *   rewardPercentiles: [25, 75],\n   * })\n   */\n  getFeeHistory: (\n    args: GetFeeHistoryParameters,\n  ) => Promise<GetFeeHistoryReturnType>\n  /**\n   * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getFilterChanges.html\n   * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)\n   *\n   * @remarks\n   * A Filter can be created from the following actions:\n   *\n   * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)\n   * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter.html)\n   * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)\n   * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)\n   *\n   * Depending on the type of filter, the return value will be different:\n   *\n   * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.\n   * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.\n   * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.\n   *\n   * @param args - {@link GetFilterChangesParameters}\n   * @returns Logs or hashes. {@link GetFilterChangesReturnType}\n   *\n   * @example\n   * // Blocks\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createBlockFilter()\n   * const hashes = await client.getFilterChanges({ filter })\n   *\n   * @example\n   * // Contract Events\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createContractEventFilter({\n   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n   *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),\n   *   eventName: 'Transfer',\n   * })\n   * const logs = await client.getFilterChanges({ filter })\n   *\n   * @example\n   * // Raw Events\n   * import { createPublicClient, http, parseAbiItem } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createEventFilter({\n   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n   *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n   * })\n   * const logs = await client.getFilterChanges({ filter })\n   *\n   * @example\n   * // Transactions\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createPendingTransactionFilter()\n   * const hashes = await client.getFilterChanges({ filter })\n   */\n  getFilterChanges: <\n    TFilterType extends FilterType,\n    TAbi extends Abi | readonly unknown[] | undefined,\n    TEventName extends string | undefined,\n    TStrict extends boolean | undefined = undefined,\n    TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: GetFilterChangesParameters<\n      TFilterType,\n      TAbi,\n      TEventName,\n      TStrict,\n      TFromBlock,\n      TToBlock\n    >,\n  ) => Promise<\n    GetFilterChangesReturnType<\n      TFilterType,\n      TAbi,\n      TEventName,\n      TStrict,\n      TFromBlock,\n      TToBlock\n    >\n  >\n  /**\n   * Returns a list of event logs since the filter was created.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getFilterLogs.html\n   * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)\n   *\n   * @remarks\n   * `getFilterLogs` is only compatible with **event filters**.\n   *\n   * @param args - {@link GetFilterLogsParameters}\n   * @returns A list of event logs. {@link GetFilterLogsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbiItem } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const filter = await client.createEventFilter({\n   *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',\n   *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),\n   * })\n   * const logs = await client.getFilterLogs({ filter })\n   */\n  getFilterLogs: <\n    TAbi extends Abi | readonly unknown[] | undefined,\n    TEventName extends string | undefined,\n    TStrict extends boolean | undefined = undefined,\n    TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args: GetFilterLogsParameters<\n      TAbi,\n      TEventName,\n      TStrict,\n      TFromBlock,\n      TToBlock\n    >,\n  ) => Promise<\n    GetFilterLogsReturnType<TAbi, TEventName, TStrict, TFromBlock, TToBlock>\n  >\n  /**\n   * Returns the current price of gas (in wei).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getGasPrice.html\n   * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)\n   *\n   * @returns The gas price (in wei). {@link GetGasPriceReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const gasPrice = await client.getGasPrice()\n   */\n  getGasPrice: () => Promise<GetGasPriceReturnType>\n  /**\n   * Returns a list of event logs matching the provided parameters.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getLogs.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/filters-and-logs/event-logs\n   * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)\n   *\n   * @param args - {@link GetLogsParameters}\n   * @returns A list of event logs. {@link GetLogsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbiItem } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const logs = await client.getLogs()\n   */\n  getLogs: <\n    TAbiEvent extends AbiEvent | undefined = undefined,\n    TAbiEvents extends\n      | readonly AbiEvent[]\n      | readonly unknown[]\n      | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n    TStrict extends boolean | undefined = undefined,\n    TFromBlock extends BlockNumber | BlockTag | undefined = undefined,\n    TToBlock extends BlockNumber | BlockTag | undefined = undefined,\n  >(\n    args?: GetLogsParameters<\n      TAbiEvent,\n      TAbiEvents,\n      TStrict,\n      TFromBlock,\n      TToBlock\n    >,\n  ) => Promise<\n    GetLogsReturnType<TAbiEvent, TAbiEvents, TStrict, TFromBlock, TToBlock>\n  >\n  /**\n   * Returns the value from a storage slot at a given address.\n   *\n   * - Docs: https://viem.sh/docs/contract/getStorageAt.html\n   * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)\n   *\n   * @param args - {@link GetStorageAtParameters}\n   * @returns The value of the storage slot. {@link GetStorageAtReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { getStorageAt } from 'viem/contract'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const code = await client.getStorageAt({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   slot: toHex(0),\n   * })\n   */\n  getStorageAt: (\n    args: GetStorageAtParameters,\n  ) => Promise<GetStorageAtReturnType>\n  /**\n   * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) given a hash or block identifier.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransaction.html\n   * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions\n   * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)\n   *\n   * @param args - {@link GetTransactionParameters}\n   * @returns The transaction information. {@link GetTransactionReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transaction = await client.getTransaction({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getTransaction: <TBlockTag extends BlockTag = 'latest'>(\n    args: GetTransactionParameters<TBlockTag>,\n  ) => Promise<GetTransactionReturnType<TChain, TBlockTag>>\n  /**\n   * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations.html\n   * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions\n   * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)\n   *\n   * @param args - {@link GetTransactionConfirmationsParameters}\n   * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const confirmations = await client.getTransactionConfirmations({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getTransactionConfirmations: (\n    args: GetTransactionConfirmationsParameters<TChain>,\n  ) => Promise<GetTransactionConfirmationsReturnType>\n  /**\n   * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms.html#transaction) an Account has broadcast / sent.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransactionCount.html\n   * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)\n   *\n   * @param args - {@link GetTransactionCountParameters}\n   * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transactionCount = await client.getTransactionCount({\n   *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  getTransactionCount: (\n    args: GetTransactionCountParameters,\n  ) => Promise<GetTransactionCountReturnType>\n  /**\n   * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt.html\n   * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/fetching-transactions\n   * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt)\n   *\n   * @param args - {@link GetTransactionReceiptParameters}\n   * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transactionReceipt = await client.getTransactionReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  getTransactionReceipt: (\n    args: GetTransactionReceiptParameters,\n  ) => Promise<GetTransactionReceiptReturnType<TChain>>\n  /**\n   * Similar to [`readContract`](https://viem.sh/docs/contract/readContract.html), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).\n   *\n   * - Docs: https://viem.sh/docs/contract/multicall.html\n   *\n   * @param args - {@link MulticallParameters}\n   * @returns An array of results with accompanying status. {@link MulticallReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const abi = parseAbi([\n   *   'function balanceOf(address) view returns (uint256)',\n   *   'function totalSupply() view returns (uint256)',\n   * ])\n   * const result = await client.multicall({\n   *   contracts: [\n   *     {\n   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *       abi,\n   *       functionName: 'balanceOf',\n   *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n   *     },\n   *     {\n   *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *       abi,\n   *       functionName: 'totalSupply',\n   *     },\n   *   ],\n   * })\n   * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]\n   */\n  multicall: <\n    TContracts extends ContractFunctionConfig[],\n    TAllowFailure extends boolean = true,\n  >(\n    args: MulticallParameters<TContracts, TAllowFailure>,\n  ) => Promise<MulticallReturnType<TContracts, TAllowFailure>>\n  /**\n   * Calls a read-only function on a contract, and returns the response.\n   *\n   * - Docs: https://viem.sh/docs/contract/readContract.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/reading-contracts\n   *\n   * @remarks\n   * A \"read-only\" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.\n   *\n   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n   *\n   * @param args - {@link ReadContractParameters}\n   * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { readContract } from 'viem/contract'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const result = await client.readContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),\n   *   functionName: 'balanceOf',\n   *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n   * })\n   * // 424122n\n   */\n  readContract: <\n    TAbi extends Abi | readonly unknown[],\n    TFunctionName extends string,\n  >(\n    args: ReadContractParameters<TAbi, TFunctionName>,\n  ) => Promise<ReadContractReturnType<TAbi, TFunctionName>>\n  /**\n   * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.\n   *\n   * - Docs: https://viem.sh/docs/contract/simulateContract.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n   *\n   * @remarks\n   * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract.html), but also supports contract write functions.\n   *\n   * Internally, uses a [Public Client](https://viem.sh/docs/clients/public.html) to call the [`call` action](https://viem.sh/docs/actions/public/call.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n   *\n   * @param args - {@link SimulateContractParameters}\n   * @returns The simulation result and write request. {@link SimulateContractReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const result = await client.simulateContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),\n   *   functionName: 'mint',\n   *   args: ['69420'],\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   * })\n   */\n  simulateContract: <\n    TAbi extends Abi | readonly unknown[] = Abi,\n    TFunctionName extends string = any,\n    TChainOverride extends Chain | undefined = undefined,\n  >(\n    args: SimulateContractParameters<\n      TAbi,\n      TFunctionName,\n      TChain,\n      TChainOverride\n    >,\n  ) => Promise<\n    SimulateContractReturnType<TAbi, TFunctionName, TChain, TChainOverride>\n  >\n  verifyMessage: (\n    args: VerifyMessageParameters,\n  ) => Promise<VerifyMessageReturnType>\n  verifyTypedData: (\n    args: VerifyTypedDataParameters,\n  ) => Promise<VerifyTypedDataReturnType>\n  /**\n   * Destroys a Filter that was created from one of the following Actions:\n   *\n   * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter.html)\n   * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter.html)\n   * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter.html)\n   *\n   * - Docs: https://viem.sh/docs/actions/public/uninstallFilter.html\n   * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)\n   *\n   * @param args - {@link UninstallFilterParameters}\n   * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'\n   *\n   * const filter = await client.createPendingTransactionFilter()\n   * const uninstalled = await client.uninstallFilter({ filter })\n   * // true\n   */\n  uninstallFilter: (\n    args: UninstallFilterParameters,\n  ) => Promise<UninstallFilterReturnType>\n  /**\n   * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html\n   * - Example: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n   * - JSON-RPC Methods:\n   *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n   *   - If a Transaction has been replaced:\n   *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n   *     - Checks if one of the Transactions is a replacement\n   *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n   *\n   * @remarks\n   * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n   *\n   * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n   *\n   * There are 3 types of Transaction Replacement reasons:\n   *\n   * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n   * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n   * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n   *\n   * @param args - {@link WaitForTransactionReceiptParameters}\n   * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const transactionReceipt = await client.waitForTransactionReceipt({\n   *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n   * })\n   */\n  waitForTransactionReceipt: (\n    args: WaitForTransactionReceiptParameters<TChain>,\n  ) => Promise<WaitForTransactionReceiptReturnType<TChain>>\n  /**\n   * Watches and returns incoming block numbers.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n   * - JSON-RPC Methods:\n   *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.\n   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n   *\n   * @param args - {@link WatchBlockNumberParameters}\n   * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = await client.watchBlockNumber({\n   *   onBlockNumber: (blockNumber) => console.log(blockNumber),\n   * })\n   */\n  watchBlockNumber: (\n    args: WatchBlockNumberParameters,\n  ) => WatchBlockNumberReturnType\n  /**\n   * Watches and returns information for incoming blocks.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchBlocks.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/blocks/watching-blocks\n   * - JSON-RPC Methods:\n   *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.\n   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newHeads\"` event.\n   *\n   * @param args - {@link WatchBlocksParameters}\n   * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = await client.watchBlocks({\n   *   onBlock: (block) => console.log(block),\n   * })\n   */\n  watchBlocks: <\n    TIncludeTransactions extends boolean = false,\n    TBlockTag extends BlockTag = 'latest',\n  >(\n    args: WatchBlocksParameters<\n      TTransport,\n      TChain,\n      TIncludeTransactions,\n      TBlockTag\n    >,\n  ) => WatchBlocksReturnType\n  /**\n   * Watches and returns emitted contract event logs.\n   *\n   * - Docs: https://viem.sh/docs/contract/watchContractEvent.html\n   *\n   * @remarks\n   * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent.html#onLogs).\n   *\n   * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead.\n   *\n   * @param args - {@link WatchContractEventParameters}\n   * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}\n   *\n   * @example\n   * import { createPublicClient, http, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = client.watchContractEvent({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),\n   *   eventName: 'Transfer',\n   *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },\n   *   onLogs: (logs) => console.log(logs),\n   * })\n   */\n  watchContractEvent: <\n    TAbi extends Abi | readonly unknown[],\n    TEventName extends string,\n    TStrict extends boolean | undefined = undefined,\n  >(\n    args: WatchContractEventParameters<TAbi, TEventName, TStrict>,\n  ) => WatchContractEventReturnType\n  /**\n   * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log).\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchEvent.html\n   * - JSON-RPC Methods:\n   *   - **RPC Provider supports `eth_newFilter`:**\n   *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n   *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n   *   - **RPC Provider does not support `eth_newFilter`:**\n   *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n   *\n   * @remarks\n   * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs).\n   *\n   * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead.\n   *\n   * @param args - {@link WatchEventParameters}\n   * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = client.watchEvent({\n   *   onLogs: (logs) => console.log(logs),\n   * })\n   */\n  watchEvent: <\n    TAbiEvent extends AbiEvent | undefined = undefined,\n    TAbiEvents extends\n      | readonly AbiEvent[]\n      | readonly unknown[]\n      | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n    TStrict extends boolean | undefined = undefined,\n  >(\n    args: WatchEventParameters<TAbiEvent, TAbiEvents, TStrict>,\n  ) => WatchEventReturnType\n  /**\n   * Watches and returns pending transaction hashes.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions.html\n   * - JSON-RPC Methods:\n   *   - When `poll: true`\n   *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.\n   *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.\n   *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `\"newPendingTransactions\"` event.\n   *\n   * @remarks\n   * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions.html#ontransactions).\n   *\n   * @param args - {@link WatchPendingTransactionsParameters}\n   * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}\n   *\n   * @example\n   * import { createPublicClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createPublicClient({\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const unwatch = await client.watchPendingTransactions({\n   *   onTransactions: (hashes) => console.log(hashes),\n   * })\n   */\n  watchPendingTransactions: (\n    args: WatchPendingTransactionsParameters<TTransport>,\n  ) => WatchPendingTransactionsReturnType\n}\n\nexport function publicActions<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n>(\n  client: Client<TTransport, TChain, TAccount>,\n): PublicActions<TTransport, TChain, TAccount> {\n  return {\n    call: (args) => call(client, args),\n    createBlockFilter: () => createBlockFilter(client),\n    createContractEventFilter: (args) =>\n      createContractEventFilter(client, args),\n    createEventFilter: (args) => createEventFilter(client, args),\n    createPendingTransactionFilter: () =>\n      createPendingTransactionFilter(client),\n    estimateContractGas: (args) => estimateContractGas(client, args as any),\n    estimateGas: (args) => estimateGas(client, args),\n    getBalance: (args) => getBalance(client, args),\n    getBlock: (args) => getBlock(client, args),\n    getBlockNumber: (args) => getBlockNumber(client, args),\n    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),\n    getBytecode: (args) => getBytecode(client, args),\n    getChainId: () => getChainId(client),\n    getEnsAddress: (args) => getEnsAddress(client, args),\n    getEnsAvatar: (args) => getEnsAvatar(client, args),\n    getEnsName: (args) => getEnsName(client, args),\n    getEnsResolver: (args) => getEnsResolver(client, args),\n    getEnsText: (args) => getEnsText(client, args),\n    getFeeHistory: (args) => getFeeHistory(client, args),\n    getFilterChanges: (args) => getFilterChanges(client, args),\n    getFilterLogs: (args) => getFilterLogs(client, args),\n    getGasPrice: () => getGasPrice(client),\n    getLogs: (args) => getLogs(client, args as any),\n    getStorageAt: (args) => getStorageAt(client, args),\n    getTransaction: (args) => getTransaction(client, args),\n    getTransactionConfirmations: (args) =>\n      getTransactionConfirmations(client, args),\n    getTransactionCount: (args) => getTransactionCount(client, args),\n    getTransactionReceipt: (args) => getTransactionReceipt(client, args),\n    multicall: (args) => multicall(client, args),\n    readContract: (args) => readContract(client, args),\n    simulateContract: (args) => simulateContract(client, args),\n    verifyMessage: (args) => verifyMessage(client, args),\n    verifyTypedData: (args) => verifyTypedData(client, args),\n    uninstallFilter: (args) => uninstallFilter(client, args),\n    waitForTransactionReceipt: (args) =>\n      waitForTransactionReceipt(client, args),\n    watchBlocks: (args) => watchBlocks(client, args),\n    watchBlockNumber: (args) => watchBlockNumber(client, args),\n    watchContractEvent: (args) => watchContractEvent(client, args),\n    watchEvent: (args) => watchEvent(client, args),\n    watchPendingTransactions: (args) => watchPendingTransactions(client, args),\n  }\n}\n", "import type { Chain } from '../types/chain.js'\nimport type { PublicRpcSchema } from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport { type Client, type ClientConfig, createClient } from './createClient.js'\nimport { type PublicActions, publicActions } from './decorators/public.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type PublicClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain>,\n    | 'batch'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'transport'\n  >\n>\n\nexport type PublicClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain,\n    undefined,\n    PublicRpcSchema,\n    PublicActions<transport, chain>\n  >\n>\n\n/**\n * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro.html) configured for a [Chain](https://viem.sh/docs/clients/chains.html).\n *\n * - Docs: https://viem.sh/docs/clients/public.html\n *\n * A Public Client is an interface to \"public\" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).\n *\n * @param config - {@link PublicClientConfig}\n * @returns A Public Client. {@link PublicClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n */\nexport function createPublicClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n>(\n  parameters: PublicClientConfig<transport, chain>,\n): PublicClient<transport, chain>\n\nexport function createPublicClient(\n  parameters: PublicClientConfig,\n): PublicClient {\n  const { key = 'public', name = 'Public Client' } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    type: 'publicClient',\n  })\n  return client.extend(publicActions)\n}\n", "import type { Abi, Narrow } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain, GetChain } from '../../types/chain.js'\nimport type { GetConstructorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js'\n\nimport {\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from './sendTransaction.js'\n\nexport type DeployContractParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = undefined,\n> = UnionOmit<\n  SendTransactionParameters<TChain, TAccount, TChainOverride>,\n  'accessList' | 'chain' | 'to' | 'data'\n> & {\n  abi: Narrow<TAbi>\n  bytecode: Hex\n} & GetChain<TChain, TChainOverride> &\n  GetConstructorArgs<TAbi>\n\nexport type DeployContractReturnType = SendTransactionReturnType\n\n/**\n * Deploys a contract to the network, given bytecode and constructor arguments.\n *\n * - Docs: https://viem.sh/docs/contract/deployContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/deploying-contracts\n *\n * @param client - Client to use\n * @param parameters - {@link DeployContractParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link DeployContractReturnType}\n *\n * @example\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { deployContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await deployContract(client, {\n *   abi: [],\n *   account: '0x…,\n *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n * })\n */\nexport function deployContract<\n  TAbi extends Abi | readonly unknown[],\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined,\n>(\n  walletClient: Client<Transport, TChain, TAccount>,\n  {\n    abi,\n    args,\n    bytecode,\n    ...request\n  }: DeployContractParameters<TAbi, TChain, TAccount, TChainOverride>,\n): Promise<DeployContractReturnType> {\n  const calldata = encodeDeployData({\n    abi,\n    args,\n    bytecode,\n  } as unknown as DeployContractParameters<\n    TAbi,\n    TChain,\n    TAccount,\n    TChainOverride\n  >)\n  return sendTransaction(walletClient, {\n    ...request,\n    data: calldata,\n  } as unknown as SendTransactionParameters<TChain, TAccount, TChainOverride>)\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport { checksumAddress } from '../../utils/address/getAddress.js'\n\nexport type GetAddressesReturnType = Address[]\n\n/**\n * Returns a list of account addresses owned by the wallet or client.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getAddresses.html\n * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n *\n * @param client - Client to use\n * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await getAddresses(client)\n */\nexport async function getAddresses<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n): Promise<GetAddressesReturnType> {\n  const addresses = await client.request({ method: 'eth_accounts' })\n  return addresses.map((address) => checksumAddress(address))\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletPermission } from '../../types/eip1193.js'\n\nexport type GetPermissionsReturnType = WalletPermission[]\n\n/**\n * Gets the wallets current permissions.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/getPermissions.html\n * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @returns The wallet permissions. {@link GetPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await getPermissions(client)\n */\nexport async function getPermissions<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(client: Client<Transport, TChain, TAccount>) {\n  const permissions = await client.request({ method: 'wallet_getPermissions' })\n  return permissions\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport { getAddress } from '../../utils/address/getAddress.js'\n\nexport type RequestAddressesReturnType = Address[]\n\n/**\n * Requests a list of accounts managed by a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses.html\n * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n *\n * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n *\n * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n *\n * @param client - Client to use\n * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestAddresses } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const accounts = await requestAddresses(client)\n */\nexport async function requestAddresses<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n): Promise<RequestAddressesReturnType> {\n  const addresses = await client.request({ method: 'eth_requestAccounts' })\n  return addresses.map((address) => getAddress(address))\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WalletPermission } from '../../types/eip1193.js'\nimport type { Prettify } from '../../types/utils.js'\n\nexport type RequestPermissionsParameters = Prettify<\n  {\n    eth_accounts: Record<string, any>\n  } & {\n    [key: string]: Record<string, any>\n  }\n>\nexport type RequestPermissionsReturnType = WalletPermission[]\n\n/**\n * Requests permissions for a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions.html\n * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n *\n * @param client - Client to use\n * @param parameters - {@link RequestPermissionsParameters}\n * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { requestPermissions } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const permissions = await requestPermissions(client, {\n *   eth_accounts: {}\n * })\n */\nexport async function requestPermissions<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  permissions: RequestPermissionsParameters,\n) {\n  return client.request({\n    method: 'wallet_requestPermissions',\n    params: [permissions],\n  })\n}\n", "import type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex, SignableMessage } from '../../types/misc.js'\nimport { stringToHex, toHex } from '../../utils/encoding/toHex.js'\n\nexport type SignMessageParameters<\n  TAccount extends Account | undefined = Account | undefined,\n> = GetAccountParameter<TAccount> & {\n  message: SignableMessage\n}\n\nexport type SignMessageReturnType = Hex\n\n/**\n * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * With the calculated signature, you can:\n * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,\n * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.\n *\n * @param client - Client to use\n * @param parameters - {@link SignMessageParameters}\n * @returns The signed message. {@link SignMessageReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   message: 'hello world',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   message: 'hello world',\n * })\n */\nexport async function signMessage<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  {\n    account: account_ = client.account,\n    message,\n  }: SignMessageParameters<TAccount>,\n): Promise<SignMessageReturnType> {\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signMessage',\n    })\n  const account = parseAccount(account_)\n  if (account.type === 'local') return account.signMessage({ message })\n\n  const message_ = (() => {\n    if (typeof message === 'string') return stringToHex(message)\n    if (message.raw instanceof Uint8Array) return toHex(message.raw)\n    return message.raw\n  })()\n\n  return client.request({\n    method: 'personal_sign',\n    params: [message_, account.address],\n  })\n}\n", "import type { TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport { parseAccount } from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AccountNotFoundError } from '../../errors/account.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport { isHex } from '../../utils/data/isHex.js'\nimport { stringify } from '../../utils/stringify.js'\nimport { validateTypedData } from '../../utils/typedData.js'\n\nexport type SignTypedDataParameters<\n  TTypedData extends TypedData | { [key: string]: unknown } = TypedData,\n  TPrimaryType extends string = string,\n  TAccount extends Account | undefined = undefined,\n> = GetAccountParameter<TAccount> &\n  TypedDataDefinition<TTypedData, TPrimaryType>\n\nexport type SignTypedDataReturnType = Hex\n\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData<\n  TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string,\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  {\n    account: account_ = client.account,\n    domain,\n    message,\n    primaryType,\n    types: types_,\n  }: SignTypedDataParameters<TTypedData, TPrimaryType, TAccount>,\n): Promise<SignTypedDataReturnType> {\n  if (!account_)\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/signTypedData',\n    })\n  const account = parseAccount(account_)\n\n  const types = {\n    EIP712Domain: [\n      typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n      domain?.version && { name: 'version', type: 'string' },\n      typeof domain?.chainId === 'number' && {\n        name: 'chainId',\n        type: 'uint256',\n      },\n      domain?.verifyingContract && {\n        name: 'verifyingContract',\n        type: 'address',\n      },\n      domain?.salt && { name: 'salt', type: 'bytes32' },\n    ].filter(Boolean),\n    ...(types_ as TTypedData),\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  } as TypedDataDefinition)\n\n  if (account.type === 'local')\n    return account.signTypedData({\n      domain,\n      primaryType,\n      types,\n      message,\n    } as TypedDataDefinition)\n\n  const typedData = stringify(\n    { domain: domain ?? {}, primaryType, types, message },\n    (_, value) => (isHex(value) ? value.toLowerCase() : value),\n  )\n  return client.request({\n    method: 'eth_signTypedData_v4',\n    params: [account.address, typedData],\n  })\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport { numberToHex } from '../../utils/encoding/toHex.js'\n\nexport type SwitchChainParameters = {\n  /** ID of Chain to switch to */\n  id: Chain['id']\n}\n\n/**\n * Switch the target chain in a wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/switchChain.html\n * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)\n *\n * @param client - Client to use\n * @param parameters - {@link SwitchChainParameters}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet, optimism } from 'viem/chains'\n * import { switchChain } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * await switchChain(client, { id: optimism.id })\n */\nexport async function switchChain<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(client: Client<Transport, TChain, TAccount>, { id }: SwitchChainParameters) {\n  await client.request({\n    method: 'wallet_switchEthereumChain',\n    params: [\n      {\n        chainId: numberToHex(id),\n      },\n    ],\n  })\n}\n", "import type { Account } from '../../accounts/types.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { WatchAssetParams } from '../../types/eip1193.js'\n\nexport type WatchAssetParameters = WatchAssetParams\nexport type WatchAssetReturnType = boolean\n\n/**\n * Adds an EVM chain to the wallet.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/watchAsset.html\n * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)\n *\n * @param client - Client to use\n * @param parameters - {@link WatchAssetParameters}\n * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchAsset } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const success = await watchAsset(client, {\n *   type: 'ERC20',\n *   options: {\n *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *     decimals: 18,\n *     symbol: 'WETH',\n *   },\n * })\n */\nexport async function watchAsset<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined = undefined,\n>(\n  client: Client<Transport, TChain, TAccount>,\n  params: WatchAssetParameters,\n): Promise<WatchAssetReturnType> {\n  const added = await client.request({\n    method: 'wallet_watchAsset',\n    params,\n  })\n  return added\n}\n", "import type { Abi, TypedData } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type GetChainIdReturnType,\n  getChainId,\n} from '../../actions/public/getChainId.js'\nimport {\n  type AddChainParameters,\n  addChain,\n} from '../../actions/wallet/addChain.js'\nimport {\n  type DeployContractParameters,\n  type DeployContractReturnType,\n  deployContract,\n} from '../../actions/wallet/deployContract.js'\nimport {\n  type GetAddressesReturnType,\n  getAddresses,\n} from '../../actions/wallet/getAddresses.js'\nimport {\n  type GetPermissionsReturnType,\n  getPermissions,\n} from '../../actions/wallet/getPermissions.js'\nimport {\n  type RequestAddressesReturnType,\n  requestAddresses,\n} from '../../actions/wallet/requestAddresses.js'\nimport {\n  type RequestPermissionsParameters,\n  type RequestPermissionsReturnType,\n  requestPermissions,\n} from '../../actions/wallet/requestPermissions.js'\nimport {\n  type SendTransactionParameters,\n  type SendTransactionReturnType,\n  sendTransaction,\n} from '../../actions/wallet/sendTransaction.js'\nimport {\n  type SignMessageParameters,\n  type SignMessageReturnType,\n  signMessage,\n} from '../../actions/wallet/signMessage.js'\nimport {\n  type SignTypedDataParameters,\n  type SignTypedDataReturnType,\n  signTypedData,\n} from '../../actions/wallet/signTypedData.js'\nimport {\n  type SwitchChainParameters,\n  switchChain,\n} from '../../actions/wallet/switchChain.js'\nimport {\n  type WatchAssetParameters,\n  type WatchAssetReturnType,\n  watchAsset,\n} from '../../actions/wallet/watchAsset.js'\nimport {\n  type WriteContractParameters,\n  type WriteContractReturnType,\n  writeContract,\n} from '../../actions/wallet/writeContract.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Client } from '../createClient.js'\nimport type { Transport } from '../transports/createTransport.js'\n\nexport type WalletActions<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n> = {\n  /**\n   * Adds an EVM chain to the wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/addChain.html\n   * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)\n   *\n   * @param args - {@link AddChainParameters}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { optimism } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   transport: custom(window.ethereum),\n   * })\n   * await client.addChain({ chain: optimism })\n   */\n  addChain: (args: AddChainParameters) => Promise<void>\n  /**\n   * Deploys a contract to the network, given bytecode and constructor arguments.\n   *\n   * - Docs: https://viem.sh/docs/contract/deployContract.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/deploying-contracts\n   *\n   * @param args - {@link DeployContractParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link DeployContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const hash = await client.deployContract({\n   *   abi: [],\n   *   account: '0x…,\n   *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n   * })\n   */\n  deployContract: <\n    TAbi extends Abi | readonly unknown[],\n    TChainOverride extends Chain | undefined,\n  >(\n    args: DeployContractParameters<TAbi, TChain, TAccount, TChainOverride>,\n  ) => Promise<DeployContractReturnType>\n  /**\n   * Returns a list of account addresses owned by the wallet or client.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getAddresses.html\n   * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)\n   *\n   * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const accounts = await client.getAddresses()\n   */\n  getAddresses: () => Promise<GetAddressesReturnType>\n  /**\n   * Returns the chain ID associated with the current network.\n   *\n   * - Docs: https://viem.sh/docs/actions/public/getChainId.html\n   * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)\n   *\n   * @returns The current chain ID. {@link GetChainIdReturnType}\n   *\n   * @example\n   * import { createWalletClient, http } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const chainId = await client.getChainId()\n   * // 1\n   */\n  getChainId: () => Promise<GetChainIdReturnType>\n  /**\n   * Gets the wallets current permissions.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/getPermissions.html\n   * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n   *\n   * @returns The wallet permissions. {@link GetPermissionsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const permissions = await client.getPermissions()\n   */\n  getPermissions: () => Promise<GetPermissionsReturnType>\n  /**\n   * Requests a list of accounts managed by a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses.html\n   * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)\n   *\n   * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).\n   *\n   * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.\n   *\n   * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const accounts = await client.requestAddresses()\n   */\n  requestAddresses: () => Promise<RequestAddressesReturnType>\n  /**\n   * Requests permissions for a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions.html\n   * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)\n   *\n   * @param args - {@link RequestPermissionsParameters}\n   * @returns The wallet permissions. {@link RequestPermissionsReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const permissions = await client.requestPermissions({\n   *   eth_accounts: {}\n   * })\n   */\n  requestPermissions: (\n    args: RequestPermissionsParameters,\n  ) => Promise<RequestPermissionsReturnType>\n  /**\n   * Creates, signs, and sends a new transaction to the network.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n   *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n   *\n   * @param args - {@link SendTransactionParameters}\n   * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const hash = await client.sendTransaction({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const hash = await client.sendTransaction({\n   *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n   *   value: 1000000000000000000n,\n   * })\n   */\n  sendTransaction: <TChainOverride extends Chain | undefined>(\n    args: SendTransactionParameters<TChain, TAccount, TChainOverride>,\n  ) => Promise<SendTransactionReturnType>\n  /**\n   * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * With the calculated signature, you can:\n   * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,\n   * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.\n   *\n   * @param args - {@link SignMessageParameters}\n   * @returns The signed message. {@link SignMessageReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const signature = await client.signMessage({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   message: 'hello world',\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const signature = await client.signMessage({\n   *   message: 'hello world',\n   * })\n   */\n  signMessage: (\n    args: SignMessageParameters<TAccount>,\n  ) => Promise<SignMessageReturnType>\n  /**\n   * Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n   * - JSON-RPC Methods:\n   *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n   *   - Local Accounts: Signs locally. No JSON-RPC request.\n   *\n   * @param client - Client to use\n   * @param args - {@link SignTypedDataParameters}\n   * @returns The signed data. {@link SignTypedDataReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const signature = await client.signTypedData({\n   *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   *\n   * @example\n   * // Account Hoisting\n   * import { createWalletClient, http } from 'viem'\n   * import { privateKeyToAccount } from 'viem/accounts'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   account: privateKeyToAccount('0x…'),\n   *   chain: mainnet,\n   *   transport: http(),\n   * })\n   * const signature = await client.signTypedData({\n   *   domain: {\n   *     name: 'Ether Mail',\n   *     version: '1',\n   *     chainId: 1,\n   *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n   *   },\n   *   types: {\n   *     Person: [\n   *       { name: 'name', type: 'string' },\n   *       { name: 'wallet', type: 'address' },\n   *     ],\n   *     Mail: [\n   *       { name: 'from', type: 'Person' },\n   *       { name: 'to', type: 'Person' },\n   *       { name: 'contents', type: 'string' },\n   *     ],\n   *   },\n   *   primaryType: 'Mail',\n   *   message: {\n   *     from: {\n   *       name: 'Cow',\n   *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n   *     },\n   *     to: {\n   *       name: 'Bob',\n   *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n   *     },\n   *     contents: 'Hello, Bob!',\n   *   },\n   * })\n   */\n  signTypedData: <\n    TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends string,\n  >(\n    args: SignTypedDataParameters<TTypedData, TPrimaryType, TAccount>,\n  ) => Promise<SignTypedDataReturnType>\n  /**\n   * Switch the target chain in a wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/switchChain.html\n   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)\n   *\n   * @param args - {@link SwitchChainParameters}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet, optimism } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * await client.switchChain({ id: optimism.id })\n   */\n  switchChain: (args: SwitchChainParameters) => Promise<void>\n  /**\n   * Adds an EVM chain to the wallet.\n   *\n   * - Docs: https://viem.sh/docs/actions/wallet/watchAsset.html\n   * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)\n   *\n   * @param args - {@link WatchAssetParameters}\n   * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const success = await client.watchAsset({\n   *   type: 'ERC20',\n   *   options: {\n   *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n   *     decimals: 18,\n   *     symbol: 'WETH',\n   *   },\n   * })\n   */\n  watchAsset: (args: WatchAssetParameters) => Promise<WatchAssetReturnType>\n  /**\n   * Executes a write function on a contract.\n   *\n   * - Docs: https://viem.sh/docs/contract/writeContract.html\n   * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n   *\n   * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.\n   *\n   * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n   *\n   * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__\n   *\n   * @param args - {@link WriteContractParameters}\n   * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash). {@link WriteContractReturnType}\n   *\n   * @example\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const hash = await client.writeContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * })\n   *\n   * @example\n   * // With Validation\n   * import { createWalletClient, custom, parseAbi } from 'viem'\n   * import { mainnet } from 'viem/chains'\n   *\n   * const client = createWalletClient({\n   *   chain: mainnet,\n   *   transport: custom(window.ethereum),\n   * })\n   * const { request } = await client.simulateContract({\n   *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n   *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n   *   functionName: 'mint',\n   *   args: [69420],\n   * }\n   * const hash = await client.writeContract(request)\n   */\n  writeContract: <\n    TAbi extends Abi | readonly unknown[],\n    TFunctionName extends string,\n    TChainOverride extends Chain | undefined,\n  >(\n    args: WriteContractParameters<\n      TAbi,\n      TFunctionName,\n      TChain,\n      TAccount,\n      TChainOverride\n    >,\n  ) => Promise<WriteContractReturnType>\n}\n\nexport function walletActions<\n  TTransport extends Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n>(\n  client: Client<TTransport, TChain, TAccount>,\n): WalletActions<TChain, TAccount> {\n  return {\n    addChain: (args) => addChain(client, args),\n    deployContract: (args) => deployContract(client, args),\n    getAddresses: () => getAddresses(client),\n    getChainId: () => getChainId(client),\n    getPermissions: () => getPermissions(client),\n    requestAddresses: () => requestAddresses(client),\n    requestPermissions: (args) => requestPermissions(client, args),\n    sendTransaction: (args) => sendTransaction(client, args),\n    signMessage: (args) => signMessage(client, args),\n    signTypedData: (args) => signTypedData(client, args),\n    switchChain: (args) => switchChain(client, args),\n    watchAsset: (args) => watchAsset(client, args),\n    writeContract: (args) => writeContract(client, args),\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport type { Account } from '../accounts/types.js'\nimport type { ParseAccount } from '../types/account.js'\nimport type { Chain } from '../types/chain.js'\nimport type { WalletRpcSchema } from '../types/eip1193.js'\nimport type { Prettify } from '../types/utils.js'\nimport { type Client, type ClientConfig, createClient } from './createClient.js'\nimport { type WalletActions, walletActions } from './decorators/wallet.js'\nimport type { Transport } from './transports/createTransport.js'\n\nexport type WalletClientConfig<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  accountOrAddress extends Account | Address | undefined =\n    | Account\n    | Address\n    | undefined,\n> = Prettify<\n  Pick<\n    ClientConfig<transport, chain, accountOrAddress>,\n    | 'account'\n    | 'cacheTime'\n    | 'chain'\n    | 'key'\n    | 'name'\n    | 'pollingInterval'\n    | 'transport'\n  >\n>\n\nexport type WalletClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n> = Prettify<\n  Client<\n    transport,\n    chain,\n    account,\n    WalletRpcSchema,\n    WalletActions<chain, account>\n  >\n>\n\n/**\n * Creates a Wallet Client with a given [Transport](https://viem.sh/docs/clients/intro.html) configured for a [Chain](https://viem.sh/docs/clients/chains.html).\n *\n * - Docs: https://viem.sh/docs/clients/wallet.html\n *\n * A Wallet Client is an interface to interact with [Ethereum Account(s)](https://ethereum.org/en/glossary/#account) and provides the ability to retrieve accounts, execute transactions, sign messages, etc. through [Wallet Actions](https://viem.sh/docs/actions/wallet/introduction.html).\n *\n * The Wallet Client supports signing over:\n * - [JSON-RPC Accounts](https://viem.sh/docs/clients/wallet.html#json-rpc-accounts) (e.g. Browser Extension Wallets, WalletConnect, etc).\n * - [Local Accounts](https://viem.sh/docs/clients/wallet.html#local-accounts-private-key-mnemonic-etc) (e.g. private key/mnemonic wallets).\n *\n * @param config - {@link WalletClientConfig}\n * @returns A Wallet Client. {@link WalletClient}\n *\n * @example\n * // JSON-RPC Account\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n *\n * @example\n * // Local Account\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…')\n *   chain: mainnet,\n *   transport: http(),\n * })\n */\nexport function createWalletClient<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  accountOrAddress extends Account | Address | undefined = undefined,\n>(\n  parameters: WalletClientConfig<transport, chain, accountOrAddress>,\n): WalletClient<transport, chain, ParseAccount<accountOrAddress>>\n\nexport function createWalletClient(\n  parameters: WalletClientConfig,\n): WalletClient {\n  const { key = 'wallet', name = 'Wallet Client', transport } = parameters\n  const client = createClient({\n    ...parameters,\n    key,\n    name,\n    transport: (opts) => transport({ ...opts, retryCount: 0 }),\n    type: 'walletClient',\n  })\n  return client.extend(walletActions)\n}\n", "import type { WebSocket } from 'isomorphic-ws'\n\nimport { RpcRequestError } from '../../errors/request.js'\nimport { UrlRequiredError } from '../../errors/transport.js'\nimport type { Hash } from '../../types/misc.js'\nimport { type RpcResponse, getSocket, rpc } from '../../utils/rpc.js'\nimport {\n  type Transport,\n  type TransportConfig,\n  createTransport,\n} from './createTransport.js'\n\ntype WebSocketTransportSubscribeParameters = {\n  onData: (data: RpcResponse) => void\n  onError?: (error: any) => void\n}\n\ntype WebSocketTransportSubscribeReturnType = {\n  subscriptionId: Hash\n  unsubscribe: () => Promise<RpcResponse<boolean>>\n}\n\ntype WebSocketTransportSubscribe = {\n  subscribe(\n    args: WebSocketTransportSubscribeParameters & {\n      /**\n       * @description Add information about compiled contracts\n       * @link https://hardhat.org/hardhat-network/docs/reference#hardhat_addcompilationresult\n       */\n      params: ['newHeads']\n    },\n  ): Promise<WebSocketTransportSubscribeReturnType>\n}\n\nexport type WebSocketTransportConfig = {\n  /** The key of the WebSocket transport. */\n  key?: TransportConfig['key']\n  /** The name of the WebSocket transport. */\n  name?: TransportConfig['name']\n  /** The max number of times to retry. */\n  retryCount?: TransportConfig['retryCount']\n  /** The base delay (in ms) between retries. */\n  retryDelay?: TransportConfig['retryDelay']\n  /** The timeout (in ms) for async WebSocket requests. Default: 10_000 */\n  timeout?: TransportConfig['timeout']\n}\n\nexport type WebSocketTransport = Transport<\n  'webSocket',\n  {\n    getSocket(): Promise<WebSocket>\n    subscribe: WebSocketTransportSubscribe['subscribe']\n  }\n>\n\n/**\n * @description Creates a WebSocket transport that connects to a JSON-RPC API.\n */\nexport function webSocket(\n  /** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */\n  url?: string,\n  config: WebSocketTransportConfig = {},\n): WebSocketTransport {\n  const { key = 'webSocket', name = 'WebSocket JSON-RPC', retryDelay } = config\n  return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {\n    const retryCount = config.retryCount ?? retryCount_\n    const timeout = timeout_ ?? config.timeout ?? 10_000\n    const url_ = url || chain?.rpcUrls.default.webSocket?.[0]\n    if (!url_) throw new UrlRequiredError()\n    return createTransport(\n      {\n        key,\n        name,\n        async request({ method, params }) {\n          const body = { method, params }\n          const socket = await getSocket(url_)\n          const { error, result } = await rpc.webSocketAsync(socket, {\n            body,\n            timeout,\n          })\n          if (error)\n            throw new RpcRequestError({\n              body,\n              error,\n              url: url_,\n            })\n          return result\n        },\n        retryCount,\n        retryDelay,\n        timeout,\n        type: 'webSocket',\n      },\n      {\n        getSocket() {\n          return getSocket(url_)\n        },\n        async subscribe({ params, onData, onError }: any) {\n          const socket = await getSocket(url_)\n          const { result: subscriptionId } = await new Promise<any>(\n            (resolve, reject) =>\n              rpc.webSocket(socket, {\n                body: {\n                  method: 'eth_subscribe',\n                  params,\n                },\n                onResponse(response) {\n                  if (response.error) {\n                    reject(response.error)\n                    onError?.(response.error)\n                    return\n                  }\n\n                  if (typeof response.id === 'number') {\n                    resolve(response)\n                    return\n                  }\n                  if (response.method !== 'eth_subscription') return\n                  onData(response.params)\n                },\n              }),\n          )\n          return {\n            subscriptionId,\n            async unsubscribe() {\n              return new Promise<any>((resolve) =>\n                rpc.webSocket(socket, {\n                  body: {\n                    method: 'eth_unsubscribe',\n                    params: [subscriptionId],\n                  },\n                  onResponse: resolve,\n                }),\n              )\n            },\n          }\n        },\n      },\n    )\n  }\n}\n", "export const maxInt8 = 2n ** (8n - 1n)\nexport const maxInt16 = 2n ** (16n - 1n)\nexport const maxInt24 = 2n ** (24n - 1n)\nexport const maxInt32 = 2n ** (32n - 1n)\nexport const maxInt40 = 2n ** (40n - 1n)\nexport const maxInt48 = 2n ** (48n - 1n)\nexport const maxInt56 = 2n ** (56n - 1n)\nexport const maxInt64 = 2n ** (64n - 1n)\nexport const maxInt72 = 2n ** (72n - 1n)\nexport const maxInt80 = 2n ** (80n - 1n)\nexport const maxInt88 = 2n ** (88n - 1n)\nexport const maxInt96 = 2n ** (96n - 1n)\nexport const maxInt104 = 2n ** (104n - 1n)\nexport const maxInt112 = 2n ** (112n - 1n)\nexport const maxInt120 = 2n ** (120n - 1n)\nexport const maxInt128 = 2n ** (128n - 1n)\nexport const maxInt136 = 2n ** (136n - 1n)\nexport const maxInt144 = 2n ** (144n - 1n)\nexport const maxInt152 = 2n ** (152n - 1n)\nexport const maxInt160 = 2n ** (160n - 1n)\nexport const maxInt168 = 2n ** (168n - 1n)\nexport const maxInt176 = 2n ** (176n - 1n)\nexport const maxInt184 = 2n ** (184n - 1n)\nexport const maxInt192 = 2n ** (192n - 1n)\nexport const maxInt200 = 2n ** (200n - 1n)\nexport const maxInt208 = 2n ** (208n - 1n)\nexport const maxInt216 = 2n ** (216n - 1n)\nexport const maxInt224 = 2n ** (224n - 1n)\nexport const maxInt232 = 2n ** (232n - 1n)\nexport const maxInt240 = 2n ** (240n - 1n)\nexport const maxInt248 = 2n ** (248n - 1n)\nexport const maxInt256 = 2n ** (256n - 1n)\n\nexport const minInt8 = -(2n ** 8n)\nexport const minInt16 = -(2n ** 16n)\nexport const minInt24 = -(2n ** 24n)\nexport const minInt32 = -(2n ** 32n)\nexport const minInt40 = -(2n ** 40n)\nexport const minInt48 = -(2n ** 48n)\nexport const minInt56 = -(2n ** 56n)\nexport const minInt64 = -(2n ** 64n)\nexport const minInt72 = -(2n ** 72n)\nexport const minInt80 = -(2n ** 80n)\nexport const minInt88 = -(2n ** 88n)\nexport const minInt96 = -(2n ** 96n)\nexport const minInt104 = -(2n ** 104n)\nexport const minInt112 = -(2n ** 112n)\nexport const minInt120 = -(2n ** 120n)\nexport const minInt128 = -(2n ** 128n)\nexport const minInt136 = -(2n ** 136n)\nexport const minInt144 = -(2n ** 144n)\nexport const minInt152 = -(2n ** 152n)\nexport const minInt160 = -(2n ** 160n)\nexport const minInt168 = -(2n ** 168n)\nexport const minInt176 = -(2n ** 176n)\nexport const minInt184 = -(2n ** 184n)\nexport const minInt192 = -(2n ** 192n)\nexport const minInt200 = -(2n ** 200n)\nexport const minInt208 = -(2n ** 208n)\nexport const minInt216 = -(2n ** 216n)\nexport const minInt224 = -(2n ** 224n)\nexport const minInt232 = -(2n ** 232n)\nexport const minInt240 = -(2n ** 240n)\nexport const minInt248 = -(2n ** 248n)\nexport const minInt256 = -(2n ** 256n)\n\nexport const maxUint8 = 2n ** 8n\nexport const maxUint16 = 2n ** 16n\nexport const maxUint24 = 2n ** 24n\nexport const maxUint32 = 2n ** 32n\nexport const maxUint40 = 2n ** 40n\nexport const maxUint48 = 2n ** 48n\nexport const maxUint56 = 2n ** 56n\nexport const maxUint64 = 2n ** 64n\nexport const maxUint72 = 2n ** 72n\nexport const maxUint80 = 2n ** 80n\nexport const maxUint88 = 2n ** 88n\nexport const maxUint96 = 2n ** 96n\nexport const maxUint104 = 2n ** 104n\nexport const maxUint112 = 2n ** 112n\nexport const maxUint120 = 2n ** 120n\nexport const maxUint128 = 2n ** 128n\nexport const maxUint136 = 2n ** 136n\nexport const maxUint144 = 2n ** 144n\nexport const maxUint152 = 2n ** 152n\nexport const maxUint160 = 2n ** 160n\nexport const maxUint168 = 2n ** 168n\nexport const maxUint176 = 2n ** 176n\nexport const maxUint184 = 2n ** 184n\nexport const maxUint192 = 2n ** 192n\nexport const maxUint200 = 2n ** 200n\nexport const maxUint208 = 2n ** 208n\nexport const maxUint216 = 2n ** 216n\nexport const maxUint224 = 2n ** 224n\nexport const maxUint232 = 2n ** 232n\nexport const maxUint240 = 2n ** 240n\nexport const maxUint248 = 2n ** 248n\nexport const maxUint256 = 2n ** 256n\n", "import {\n  ChainNotConfiguredForConnectorError,\n  ConnectorNotFoundError\n} from \"./chunk-ZCAPXGBX.js\";\nimport {\n  normalizeChainId\n} from \"./chunk-OQILYQDO.js\";\nimport {\n  Connector,\n  __privateAdd,\n  __privateGet,\n  __privateSet,\n  __publicField\n} from \"./chunk-QYMCVNHT.js\";\n\n// src/injected.ts\nimport {\n  ResourceUnavailableRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  createWalletClient,\n  custom,\n  getAddress,\n  numberToHex\n} from \"viem\";\n\n// src/utils/getInjectedName.ts\nfunction getInjectedName(ethereum) {\n  if (!ethereum)\n    return \"Injected\";\n  const getName = (provider) => {\n    if (provider.isApexWallet)\n      return \"Apex Wallet\";\n    if (provider.isAvalanche)\n      return \"Core Wallet\";\n    if (provider.isBackpack)\n      return \"Backpack\";\n    if (provider.isBifrost)\n      return \"Bifrost Wallet\";\n    if (provider.isBitKeep)\n      return \"BitKeep\";\n    if (provider.isBitski)\n      return \"Bitski\";\n    if (provider.isBlockWallet)\n      return \"BlockWallet\";\n    if (provider.isBraveWallet)\n      return \"Brave Wallet\";\n    if (provider.isCoinbaseWallet)\n      return \"Coinbase Wallet\";\n    if (provider.isDawn)\n      return \"Dawn Wallet\";\n    if (provider.isDefiant)\n      return \"Defiant\";\n    if (provider.isEnkrypt)\n      return \"Enkrypt\";\n    if (provider.isExodus)\n      return \"Exodus\";\n    if (provider.isFrame)\n      return \"Frame\";\n    if (provider.isFrontier)\n      return \"Frontier Wallet\";\n    if (provider.isGamestop)\n      return \"GameStop Wallet\";\n    if (provider.isHaqqWallet)\n      return \"HAQQ Wallet\";\n    if (provider.isHyperPay)\n      return \"HyperPay Wallet\";\n    if (provider.isImToken)\n      return \"ImToken\";\n    if (provider.isHaloWallet)\n      return \"Halo Wallet\";\n    if (provider.isKuCoinWallet)\n      return \"KuCoin Wallet\";\n    if (provider.isMathWallet)\n      return \"MathWallet\";\n    if (provider.isNovaWallet)\n      return \"Nova Wallet\";\n    if (provider.isOkxWallet || provider.isOKExWallet)\n      return \"OKX Wallet\";\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)\n      return \"1inch Wallet\";\n    if (provider.isOpera)\n      return \"Opera\";\n    if (provider.isPhantom)\n      return \"Phantom\";\n    if (provider.isPortal)\n      return \"Ripio Portal\";\n    if (provider.isRabby)\n      return \"Rabby Wallet\";\n    if (provider.isRainbow)\n      return \"Rainbow\";\n    if (provider.isStatus)\n      return \"Status\";\n    if (provider.isTalisman)\n      return \"Talisman\";\n    if (provider.isTally)\n      return \"Taho\";\n    if (provider.isTokenPocket)\n      return \"TokenPocket\";\n    if (provider.isTokenary)\n      return \"Tokenary\";\n    if (provider.isTrust || provider.isTrustWallet)\n      return \"Trust Wallet\";\n    if (provider.isTTWallet)\n      return \"TTWallet\";\n    if (provider.isXDEFI)\n      return \"XDEFI Wallet\";\n    if (provider.isZerion)\n      return \"Zerion\";\n    if (provider.isMetaMask)\n      return \"MetaMask\";\n  };\n  if (ethereum.providers?.length) {\n    const nameSet = /* @__PURE__ */ new Set();\n    let unknownCount = 1;\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n      nameSet.add(name);\n    }\n    const names = [...nameSet];\n    if (names.length)\n      return names;\n    return names[0] ?? \"Injected\";\n  }\n  return getName(ethereum) ?? \"Injected\";\n}\n\n// src/injected.ts\nvar _provider;\nvar InjectedConnector = class extends Connector {\n  constructor({\n    chains,\n    options: options_\n  } = {}) {\n    const options = {\n      shimDisconnect: true,\n      getProvider() {\n        if (typeof window === \"undefined\")\n          return;\n        const ethereum = window.ethereum;\n        if (ethereum?.providers)\n          return ethereum.providers[0];\n        return ethereum;\n      },\n      ...options_\n    };\n    super({ chains, options });\n    __publicField(this, \"id\", \"injected\");\n    __publicField(this, \"name\");\n    __publicField(this, \"ready\");\n    __privateAdd(this, _provider, void 0);\n    __publicField(this, \"shimDisconnectKey\", `${this.id}.shimDisconnect`);\n    __publicField(this, \"onAccountsChanged\", (accounts) => {\n      if (accounts.length === 0)\n        this.emit(\"disconnect\");\n      else\n        this.emit(\"change\", {\n          account: getAddress(accounts[0])\n        });\n    });\n    __publicField(this, \"onChainChanged\", (chainId) => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", { chain: { id, unsupported } });\n    });\n    __publicField(this, \"onDisconnect\", async (error) => {\n      if (error.code === 1013) {\n        const provider = await this.getProvider();\n        if (provider) {\n          const isAuthorized = await this.getAccount();\n          if (isAuthorized)\n            return;\n        }\n      }\n      this.emit(\"disconnect\");\n      if (this.options.shimDisconnect)\n        this.storage?.removeItem(this.shimDisconnectKey);\n    });\n    const provider = options.getProvider();\n    if (typeof options.name === \"string\")\n      this.name = options.name;\n    else if (provider) {\n      const detectedName = getInjectedName(provider);\n      if (options.name)\n        this.name = options.name(detectedName);\n      else {\n        if (typeof detectedName === \"string\")\n          this.name = detectedName;\n        else\n          this.name = detectedName[0];\n      }\n    } else\n      this.name = \"Injected\";\n    this.ready = !!provider;\n  }\n  async connect({ chainId } = {}) {\n    try {\n      const provider = await this.getProvider();\n      if (!provider)\n        throw new ConnectorNotFoundError();\n      if (provider.on) {\n        provider.on(\"accountsChanged\", this.onAccountsChanged);\n        provider.on(\"chainChanged\", this.onChainChanged);\n        provider.on(\"disconnect\", this.onDisconnect);\n      }\n      this.emit(\"message\", { type: \"connecting\" });\n      const accounts = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n      const account = getAddress(accounts[0]);\n      let id = await this.getChainId();\n      let unsupported = this.isChainUnsupported(id);\n      if (chainId && id !== chainId) {\n        const chain = await this.switchChain(chainId);\n        id = chain.id;\n        unsupported = this.isChainUnsupported(id);\n      }\n      if (this.options.shimDisconnect)\n        this.storage?.setItem(this.shimDisconnectKey, true);\n      return { account, chain: { id, unsupported } };\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error))\n        throw new UserRejectedRequestError(error);\n      if (error.code === -32002)\n        throw new ResourceUnavailableRpcError(error);\n      throw error;\n    }\n  }\n  async disconnect() {\n    const provider = await this.getProvider();\n    if (!provider?.removeListener)\n      return;\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n    if (this.options.shimDisconnect)\n      this.storage?.removeItem(this.shimDisconnectKey);\n  }\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n    return getAddress(accounts[0]);\n  }\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    return provider.request({ method: \"eth_chainId\" }).then(normalizeChainId);\n  }\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider)\n      __privateSet(this, _provider, provider);\n    return __privateGet(this, _provider);\n  }\n  async getWalletClient({\n    chainId\n  } = {}) {\n    const [provider, account] = await Promise.all([\n      this.getProvider(),\n      this.getAccount()\n    ]);\n    const chain = this.chains.find((x) => x.id === chainId);\n    if (!provider)\n      throw new Error(\"provider is required.\");\n    return createWalletClient({\n      account,\n      chain,\n      transport: custom(provider)\n    });\n  }\n  async isAuthorized() {\n    try {\n      if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))\n        return false;\n      const provider = await this.getProvider();\n      if (!provider)\n        throw new ConnectorNotFoundError();\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      return false;\n    }\n  }\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    const id = numberToHex(chainId);\n    try {\n      await Promise.all([\n        provider.request({\n          method: \"wallet_switchEthereumChain\",\n          params: [{ chainId: id }]\n        }),\n        new Promise(\n          (res) => this.on(\"change\", ({ chain }) => {\n            if (chain?.id === chainId)\n              res();\n          })\n        )\n      ]);\n      return this.chains.find((x) => x.id === chainId) ?? {\n        id: chainId,\n        name: `Chain ${id}`,\n        network: `${id}`,\n        nativeCurrency: { name: \"Ether\", decimals: 18, symbol: \"ETH\" },\n        rpcUrls: { default: { http: [\"\"] }, public: { http: [\"\"] } }\n      };\n    } catch (error) {\n      const chain = this.chains.find((x) => x.id === chainId);\n      if (!chain)\n        throw new ChainNotConfiguredForConnectorError({\n          chainId,\n          connectorId: this.id\n        });\n      if (error.code === 4902 || error?.data?.originalError?.code === 4902) {\n        try {\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [\n              {\n                chainId: id,\n                chainName: chain.name,\n                nativeCurrency: chain.nativeCurrency,\n                rpcUrls: [chain.rpcUrls.public?.http[0] ?? \"\"],\n                blockExplorerUrls: this.getBlockExplorerUrls(chain)\n              }\n            ]\n          });\n          const currentChainId = await this.getChainId();\n          if (currentChainId !== chainId)\n            throw new UserRejectedRequestError(\n              new Error(\"User rejected switch after adding network.\")\n            );\n          return chain;\n        } catch (error2) {\n          throw new UserRejectedRequestError(error2);\n        }\n      }\n      if (this.isUserRejectedRequestError(error))\n        throw new UserRejectedRequestError(error);\n      throw new SwitchChainError(error);\n    }\n  }\n  async watchAsset({\n    address,\n    decimals = 18,\n    image,\n    symbol\n  }) {\n    const provider = await this.getProvider();\n    if (!provider)\n      throw new ConnectorNotFoundError();\n    return provider.request({\n      method: \"wallet_watchAsset\",\n      params: {\n        type: \"ERC20\",\n        options: {\n          address,\n          decimals,\n          image,\n          symbol\n        }\n      }\n    });\n  }\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n};\n_provider = new WeakMap();\n\nexport {\n  InjectedConnector\n};\n"],
  "mappings": "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",
  "names": ["EventEmitter", "EventEmitter", "id", "id", "docsPath", "err", "docsPath", "docsPath", "docsPath", "listeners", "cleanup", "poll", "cacheKey", "id", "event", "args", "docsPath", "request", "id", "size", "key", "fetch", "transport", "transports_", "sample", "response", "body", "webSocket", "id", "http", "wait", "body", "bytesRegex", "integerRegex", "integerRegex", "bytesRegex", "struct", "docsPath", "custom", "res", "id", "event", "id", "id", "index", "args", "verifyMessage", "verifyTypedData", "block", "verifyMessage", "verifyTypedData", "id", "webSocket", "id", "provider"]
}
